"use strict";var e=require("bitcoin-computer-bitcore");var t=require("chai");require("ses");var o=require("axios");require("child_process");var n=require("crypto");var r=require("crypto-js");var i=require("eciesjs");var c=require("@endo/static-module-record");var s=require("exponential-backoff");var a=require("http");var d=require("https");var u=require("url");var l=require("util");function p(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function h(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(o){if("default"!==o){var n=Object.getOwnPropertyDescriptor(e,o);Object.defineProperty(t,o,n.get?n:{enumerable:!0,get:function(){return e[o]}})}})),t.default=e,Object.freeze(t)}var v=p(o);var y=p(n);var _=p(r);var g=h(i);var f=p(a);var b=p(d);var w=p(u);var m=p(l);function k(e,t){var o={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(n=Object.getOwnPropertySymbols(e);r<n.length;r++)t.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(e,n[r])&&(o[n[r]]=e[n[r]])}return o}function x(e,t,o,n){return new(o||(o=Promise))((function(r,i){function c(e){try{a(n.next(e))}catch(e){i(e)}}function s(e){try{a(n.throw(e))}catch(e){i(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof o?t:new o((function(e){e(t)}))).then(c,s)}a((n=n.apply(e,t||[])).next())}))}const S=e=>new Compartment({}).evaluate(e);const q=(e,t,o)=>new Compartment({target:e,thisArgument:t,argumentsList:o}).evaluate("Reflect.apply(target, thisArgument, argumentsList)");const j=(e,t)=>new Compartment({target:e,argumentsList:t}).evaluate(`Reflect.construct(${e}, argumentsList)`);const{crypto:O}=e.Bitcoin;const C=(e,t)=>{const o=Date.now();const n=O.Hash.sha256(Buffer.from(t+o));const r=[O.ECDSA.sign(n,e,"big").toString("hex"),e.publicKey.toString(),o];return`Bearer ${Buffer.from(r.join(":")).toString("base64")}`};class B{constructor(e,t,o={}){this.baseUrl=e,this.headers=o,this.privateKey=t}get(e){return x(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:C(this.privateKey,this.baseUrl)}:{};return(yield v.default.get(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}post(e,t){return x(this,void 0,void 0,(function*(){const o=this.privateKey?{Authentication:C(this.privateKey,this.baseUrl)}:{};return(yield v.default.post(`${this.baseUrl}${e}`,t,{headers:Object.assign(Object.assign({},this.headers),o)})).data}))}delete(e){return x(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:C(this.privateKey,this.baseUrl)}:{};return(yield v.default.delete(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}}const R=process.env.CHAIN||"LTC";const $=process.env.NETWORK||"testnet";const T=process.env.BCN_URL||"https://node.bitcoincomputer.io";process.env.RPC_USER,process.env.RPC_PASSWORD;const I=parseInt(process.env.BC_DUST_LIMIT||"",10)||1546;parseInt(process.env.BC_DEFAULT_FEE||"",10),parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10);const A="";const{PublicKey:E,Mnemonic:P,crypto:K}=e.Bitcoin;const{Point:L}=K;function U(e){return Buffer.from(e,"hex").toString().replace(/\0/g,"")}function D(e,t){return e.slice(t)+e.slice(0,t)}function N(e,t,o){if(e.length*Math.log2(t)>53)throw new Error(`Input too large ${e.length} ${Math.log2(t)}`);if(![2,10,16].includes(t)||![2,10,16].includes(o))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===t&&e.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===t&&e.length%2!=0)throw new Error("Hex strings must be of even length.");const n=parseInt(e,t).toString(o);return 2===o?n.padStart(8*Math.ceil(n.length/8),"0"):16===o?n.padStart(2*Math.ceil(n.length/2),"0"):n}function M(e,t){const o=new RegExp(`.{1,${t}}`,"g");return e.match(o)||[]}function H(e){return M(e,2).map((e=>N(e,16,2))).join("")}function F(e){return M(e,8).map((e=>N(e,2,16))).join("")}function W(e){return e.toString(16).padStart(3,"0")}function J(e){return parseInt(e,16)}function z(e){if(62!==e.length)throw new Error("Input to hexToPublicKey must be of length 62");let t=!1;let o=0;let n;for(;!t;){if(o>=256)throw new Error("Something went wrong storing data");const r=o.toString(16).padStart(2,"0")+F(D(H(e).padStart(64,"0"),o));try{n=L.fromX(!1,r),t=!0}catch(e){o+=1}}if(!n)throw new Error("Something went wrong storing data");return new E(n)}function G(e){const t=e.point.getX().toString("hex").padStart(64,"0");const o=N(t.slice(0,2),16,10);return F((r=parseInt(o,10),(n=H(t.slice(2))).slice(-r)+n.slice(0,-r)));var n,r}function Y(e){return new Promise((t=>{setTimeout(t,e)}))}function Q(e=R,t=$){if("testnet"===t||"regtest"===t)return 1;if("BTC"===e)return 0;if("LTC"===e)return 2;if("DOGE"===e)return 3;if("BCH"===e)return 145;if("BSV"===e)return 236;throw new Error(`Unsupported chain ${e}`)}function V({purpose:e=44,coinType:t=2,account:o=0}={}){return`m/${e.toString()}'/${t.toString()}'/${o.toString()}'`}function X(e=R,t=$){return V({coinType:Q(e,t)})}function Z(){return Math.round(Math.random()*Math.pow(2,31))}function ee({chain:e=R,network:t=$,account:o=Z()}={}){return V({account:o,coinType:Q(e,t)})}function te(e,t){const o=function(e,t){return((e,t,o={})=>{const{path:n="m/44'/0'/0'/0",passphrase:r=""}=o;let i=e.toHDPrivateKey(r,t);return n&&(i=i.derive(n)),i.privateKey})(new P("replace this seed"),t,{path:X(e,t),passphrase:""})}(e,t);return E.fromPrivateKey(o)}function oe({mnemonic:e=new P,path:t=X(),passphrase:o=A,network:n=$}){if(void 0!==e&&void 0!==t&&void 0!==o&&void 0!==n)return e.toHDPrivateKey(o,n).deriveChild(t);throw new Error(`Missing required parameters${JSON.stringify({mnemonic:e,path:t,passphrase:o,network:n})}`)}const{Transaction:ne,Mnemonic:re}=e.Bitcoin;const{UnspentOutput:ie}=ne;function ce(e){if(!/^[0-9A-Fa-f]{64}$/.test(e))throw new Error(`Invalid txId: ${e}`)}function se(e){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(e))throw new Error(`Invalid outId: ${e}`)}function ae(e){se(e);const[t,o]=e.split("/");return{txId:t,outputIndex:parseInt(o,10)}}class de{constructor(e={}){const{chain:t=R,network:o=$,mnemonic:n="",path:r=X(e.chain,e.network),passphrase:i=A,url:c=T}=e;this.chain=t.toUpperCase(),this.network=o.toLowerCase(),this.mnemonic=new re(n.toString()),this.path=r,this.passphrase=i,this.bcn=new B(c,this.privateKey)}get privateKey(){return oe(this).privateKey}getBalance(e){return x(this,void 0,void 0,(function*(){const{chain:t,network:o}=this;return yield this.bcn.get(`/v1/${t}/${o}/address/${e}/balance`)}))}getTransactions(e){return x(this,void 0,void 0,(function*(){return(yield this.getRawTxs(e)).map((e=>new ne(e)))}))}getRawTxs(e){return x(this,void 0,void 0,(function*(){e.map(ce);const{chain:t,network:o}=this;return this.bcn.post(`/v1/${t}/${o}/tx/bulk/`,{txIds:e})}))}sendTransaction(e){return x(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{rawTx:e})}))}getUtxosByAddress(e){return x(this,void 0,void 0,(function*(){const{chain:t,network:o}=this;return(yield this.bcn.get(`/v1/${t}/${o}/wallet/${e.toString()}/utxos`)).map((({rev:e,scriptPubKey:t,satoshis:o})=>{const[n,r]=e.split("/");return new ie({txId:n,outputIndex:parseInt(r,10),satoshis:o,script:t})}))}))}query({publicKey:e,classHash:t}){return x(this,void 0,void 0,(function*(){if(void 0===e&&void 0===t)throw new Error("Query parameters cannot be empty.");let o="";e&&(o+=`?publicKey=${e}`),t&&(o+=0===o.length?"?":"&",o+=`classHash=${t}`);const{chain:n,network:r}=this;return this.bcn.get(`/v1/${n}/${r}/non-standard-utxos${o}`)}))}idsToRevs(e){return x(this,void 0,void 0,(function*(){e.map(se);const{chain:t,network:o}=this;return this.bcn.post(`/v1/${t}/${o}/revs`,{ids:e})}))}rpc(e,t){return x(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/rpc`,{method:e,params:t})}))}static getSecretOutput({_url:e,privateKey:t}){return x(this,void 0,void 0,(function*(){const o=e.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new B(r,t);return{host:r,data:yield i.get(`/v1/store/${n}`)}}))}static setSecretOutput({secretOutput:e,host:t,privateKey:o}){return x(this,void 0,void 0,(function*(){return new B(t,o).post("/v1/store/",e)}))}static deleteSecretOutput({_url:e,privateKey:t}){return x(this,void 0,void 0,(function*(){const o=e.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new B(r,t);yield i.delete(`/v1/store/${n}`)}))}get url(){return this.bcn.baseUrl}}const{PublicKey:ue,Script:le}=e.Bitcoin;function pe(e,t,o,n){if(e.length>3)throw new Error("Too many owners");return function(e,t,o,n){const r=n?[...e,te(t,o).toBuffer()]:e;const i=new le;return i.add("OP_1"),r.forEach((e=>{i.add(e)})),i.add(`OP_${r.length}`),i.add("OP_CHECKMULTISIG"),i}(e.map((e=>e.toBuffer())),t,o,n)}function he(e,t){return function(e,t){const o=e.chunks.filter((e=>e.buf));return(t?o.slice(0,-1):o).map((e=>e.buf))}(e,t).map((e=>ue.fromBuffer(e)))}function ve(e){return Buffer.from(_.default.SHA256(e).toString(),"hex").toString("hex").substr(0,4)}function ye(e){return`${ve(e)};${e}`}function _e(e){const t=e.substr(0,4);const o=e.substr(5);if(!function(e,t){return ve(e)===t}(o,t))throw new Error("Decryption failure");return o}function ge(e){if(void 0!==e._readers){const{_readers:t,_url:o,_owners:n,_amount:r}=e,i=k(e,["_readers","_url","_owners","_amount"]);const c=function(e,t){const o=y.default.randomBytes(32).toString("hex");const n=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const o=Buffer.from(t,"hex").toString("binary");const n=ye(e);return _.default.AES.encrypt(n,o).toString()}(e,o);const r=t.map((e=>function(e,t){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(t))throw new Error("Invalid publicKey");const o=ye(e);return g.encrypt(t,Buffer.from(o,"utf8")).toString("base64")}(o,e)));return{__cypher:n,__secrets:r}}(JSON.stringify(i),t);return void 0!==o&&(c._url=o),void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return e}const{Transaction:fe}=e.Bitcoin;const{Output:be,UnspentOutput:we}=fe;class me{constructor({restClient:e=new de}={}){this.tx=new fe,this.tx.feePerKb(2e4),this.outData=[],this.restClient=e}get txId(){return this.tx.id}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get inputs(){return this.tx.inputs.map((e=>`${e.prevTxId.toString("hex")}/${e.outputIndex}`))}get inRevs(){const{enc:e}=this;let[t]=e;return t=Number.isFinite(t)?t:0,this.tx.inputs.slice(0,t).map((({prevTxId:e,outputIndex:t})=>`${e.toString("hex")}/${t}`))}get outRevs(){const{enc:e}=this;let[,t]=e;return t=Number.isFinite(t)?t:0,Array.from(Array(t).keys()).map((e=>`${this.tx.id}/${e}`))}get opReturns(){try{const{outputs:e}=this.tx;return e.filter((({script:e})=>e.isDataOut())).map((({script:e})=>e.getData())).map((e=>e.toString())).join()}catch(e){return""}}get enc(){return M(this.opReturns.slice(0,9),3).map(J)}get dataPrefix(){return this.opReturns.slice(9)}isFullyFunded(){return this.tx._getInputAmount()-this.tx._getOutputAmount()>=this.tx.getFee()}getOwnerOutputs(){const{enc:e}=this;const[,t=0]=e;return this.tx.outputs.slice(0,t)}getDataOutputs(){const{enc:e}=this;const[,t,o]=e;return this.tx.outputs.slice(t,o)}getOutData(){return x(this,void 0,void 0,(function*(){try{const e=this.getDataOutputs().map((e=>e.script)).map((e=>he(e,!0))).flat().map(G).map(U).join("");const{dataPrefix:t}=this;const o=JSON.parse(t+e);const n=this.restClient.privateKey.toBuffer().toString("hex");const r=this.getOwnerOutputs();if(r.length!==o.length)throw new Error("Inconsistent state");const i=r.map(((e,t)=>Object.assign(Object.assign({},o[t]),{_owners:he(e.script,!1).map((e=>e.toString())),_amount:e.satoshis})));return Promise.all(i.map((e=>x(this,void 0,void 0,(function*(){try{const t=yield function(e){return t=>x(this,void 0,void 0,(function*(){if(function(e){return void 0!==e._url}(t)){const{_url:o}=t,n=k(t,["_url"]);const{host:r,data:i}=yield de.getSecretOutput({_url:o,privateKey:e});return Object.assign(Object.assign(Object.assign({},n),JSON.parse(i)),{_url:r})}return t}))}(this.restClient.privateKey)(e);return function(e,t){if(function(e){return void 0!==e.__cypher&&void 0!==e.__secrets}(e)){const{__cypher:o,__secrets:n}=e,r=k(e,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},r),JSON.parse(function({__cypher:e,__secrets:t},o){let n="";if(o.forEach((o=>{t.forEach((t=>{try{const r=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid privateKey");return _e(g.decrypt(t,Buffer.from(e,"base64")).toString("utf8"))}(t,o);n=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const o=Buffer.from(t,"hex").toString("binary");return _e(_.default.AES.decrypt(e,o).toString(_.default.enc.Utf8))}(e,r)}catch(e){const t=["Decryption failure","Unsupported state or unable to authenticate data"];if(e instanceof Error&&!t.includes(e.message))throw e}}))})),n)return n;throw new Error("Decryption failure")}({__cypher:o,__secrets:n},t))),{_readers:[]})}return e}(t,[n])}catch(e){return null}})))))}catch(e){return[]}}))}getOwners(){return this.getOwnerOutputs().map((e=>he(e.script,!1).map((e=>e.toString()))))}getAmounts(){return this.getOwnerOutputs().map((e=>e.satoshis))}spendFromData(t){return x(this,void 0,void 0,(function*(){if(!t.length)return;const o=t.map(ae);const n=o.map((e=>e.txId));const r=yield this.restClient.getTransactions(n);for(let t=0;t<o.length;t+=1){const{txId:n,outputIndex:i}=o[t];const{outputs:c}=r[t];const s=c[i];const a=Math.round(s.satoshis);const d=new e.Bitcoin.Script(s.script);const u=new we({txId:n,outputIndex:i,satoshis:a,script:d});const l=he(d,!1).map((e=>e.toString()));this.tx.from([u],l,1)}}))}createDataOuts(t){t.forEach((({_amount:t,_owners:o=[]})=>{if(Array.isArray(o)&&o.length>3)throw new Error("Too many owners.");const n=o.map((t=>e.Bitcoin.PublicKey.fromString(t)));const r=t||I;const i=pe(n,this.chain,this.network,!1);this.tx.addOutput(new be({script:i,satoshis:r}))}));const o=t.map((e=>k(e,["_amount","_owners"])));const n=I;const r=JSON.stringify(o);const i=r.slice(0,71);const c=function(e,t,o,n){var r;return function(e,t){const o=[];for(let t=0;t<e.length;t+=2)o.push(e.slice(t,t+2));return o}(M((r=e,Buffer.from(r).toString("hex")),62).map((e=>e.padStart(62,"0"))).map(z)).map((e=>pe(e,t,o,!0)))}(r.slice(71),this.chain,this.network);const s=W(this.tx.inputs.length)+W(this.tx.outputs.length)+W(this.tx.outputs.length+c.length);c.forEach((e=>{this.tx.addOutput(new be({script:e,satoshis:n}))})),this.tx.addData(s+i)}static fromTxHex({hex:e="",restClient:t=new de}){return x(this,void 0,void 0,(function*(){let o=[];let n=[];let r=[];const i=new this({restClient:t});i.tx.fromString(e);try{o=yield i.getOutData()}catch(e){}try{n=i.getOwners()}catch(e){}try{r=i.getAmounts()}catch(e){}return i.outData=o.map(((e,t)=>Object.assign(Object.assign({},e),{_owners:n[t],_amount:r[t]}))),i}))}static fromTxId({txId:e="",restClient:t=new de}){return x(this,void 0,void 0,(function*(){const[o]=yield t.getRawTxs([e]);return this.fromTxHex({hex:o,restClient:t})}))}}class ke{constructor(e={}){this.restClient=new de(e)}derive(e="0"){const t=`${this.path}${this.path.length>0?"/":""}${e}`;const{chain:o,network:n,url:r,mnemonic:i,passphrase:c}=this.restClient;return new ke({chain:o,network:n,url:r,mnemonic:i.toString(),path:t,passphrase:c})}getBalance(){return x(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.address)}))}getUtxosByAmount(e){return x(this,void 0,void 0,(function*(){const t=yield this.restClient.getUtxosByAddress(this.address);let o=0;const n=[];!function(e){const t=e;for(let e=t.length-1;e>0;e-=1){const o=Math.floor(Math.random()*(e+1));[t[e],t[o]]=[t[o],t[e]]}}(t);for(const r of t)if(o+=r.satoshis,n.push(r),o>=e)return n;const{network:r,chain:i}=this.restClient;const c=this.address.toString();throw new Error(`Insufficient balance in address ${c} on ${r} ${i}. Found ${o}, required ${e}.`)}))}fundAndSendTx(t){return x(this,void 0,void 0,(function*(){t.tx.feePerKb(4e4);const o=t.tx.outputs.length;const{chain:n,network:r}=this.restClient;t.tx.to(function(e,t){const o={"any-testnet":"uTKUDCkpo12vstJBsMWmrTPz9wFE6DuzGH","BTC-mainnet":"igpnnoLziUyxtQuWYCP13gHYVhUru6iLaY","LTC-mainnet":"t77o829ngHnuUorwDkf129fL6ERLFNqKG8","DOGE-mainnet":"XfNRUdvrv6uCDbCF5xJ18UYwVkkefkXvEd","BCH-mainnet":"CSAkkS8Mro9mYRqhksS1FyYrsnSE5MVQ5m"};return D("testnet"===t||"regtest"===t?o["any-testnet"]:o[`${e}-${t}`],19)}(n,r),0);const i=yield this.restClient.getUtxosByAddress(this.address);if(t.tx.change(this.address),0===i.length)throw new Error(`Insufficient balance in address ${this.address}.`);let c=0;let s=0;let a=0;do{const[o]=i.splice(0,1);t.tx.from([new e.Bitcoin.Transaction.UnspentOutput(o)]),t.tx.sign(this.privateKey,1),s=t.tx.toString().length,t.tx.fee(2e4*s*2),t.tx._updateChangeOutput(),a=t.tx._getInputAmount()-t.tx._getOutputAmount(),c=a/s*1e3}while(0!==i.length&&c<4e4);if(c<4e4&&0===i.length)throw new Error(`Insufficient balance in address ${this.address}. Current fee_per_kb ${c}. Fee ${a}. Utxo set size ${i.length}. CTransaction size ${s} Inputs ${JSON.stringify(t.tx.inputs,null,2)} Outpus ${JSON.stringify(t.tx.outputs,null,2)}`);if(s=t.tx.toString().length,a=Math.ceil(s/1e3*2e4),t.tx.fee(a),t.tx.outputs[o].satoshis=a,t.tx._outputAmount=void 0,t.tx.feePerKb(2e4),t.tx._outputAmount=void 0,t.tx._updateChangeOutput(),!1===t.isFullyFunded()||!1===t.tx.verify())throw new Error(`Something went wrong. Address ${this.address}. Transaction: ${JSON.stringify(t.tx,null,2)}`);return t.tx.sign(this.privateKey,1),this.restClient.sendTransaction(t.tx.toString())}))}send(e,t){return x(this,void 0,void 0,(function*(){const{restClient:o}=this;const n=new me({restClient:o});return n.tx.to(t,e),this.fundAndSendTx(n)}))}get hdPrivateKey(){return oe(this.restClient)}get privateKey(){return this.hdPrivateKey.privateKey}get publicKey(){return this.hdPrivateKey.publicKey}get passphrase(){return this.restClient.passphrase}get path(){return this.restClient.path}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get url(){return this.restClient.url}get mnemonic(){return this.restClient.mnemonic}get address(){return this.publicKey.toAddress(this.restClient.network)}}class xe{constructor(e={}){this.wallet=new ke(e)}fromTxHex(e){return x(this,void 0,void 0,(function*(){const{restClient:t}=this.wallet;return me.fromTxHex({hex:e,restClient:t})}))}fromTxId(e){return x(this,void 0,void 0,(function*(){const[t]=yield this.wallet.restClient.getRawTxs([e]);return this.fromTxHex(t)}))}get(e){return x(this,void 0,void 0,(function*(){const t=e.map(ae);return Promise.all(t.map((({txId:e,outputIndex:t})=>x(this,void 0,void 0,(function*(){const{outData:o}=yield this.fromTxId(e);if(t>o.length)throw new Error("Index out of bounds");return o[t]})))))}))}put(e){return this.update([],e)}createTx(e,t){return x(this,void 0,void 0,(function*(){const{wallet:o}=this;const{restClient:n}=o;const r=new me({restClient:n});const{privateKey:i,publicKey:c}=o;const s=t.map((e=>{var{_owners:t}=e,o=k(e,["_owners"]);return Object.assign({_owners:t||[c.toString()]},o)})).map(ge);const a=yield Promise.all(s.map(function(e){return t=>x(this,void 0,void 0,(function*(){if(void 0!==t._url){const{_url:o,_owners:n,_amount:r}=t,i=k(t,["_url","_owners","_amount"]);const c=yield de.setSecretOutput({host:o,secretOutput:{data:JSON.stringify(i)},privateKey:e});return void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return t}))}(i)));return yield r.spendFromData(e),yield r.createDataOuts(a),r}))}update(e,t){return x(this,void 0,void 0,(function*(){const o=yield this.createTx(e,t);return yield this.wallet.fundAndSendTx(o),o.outRevs}))}}const Se=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__func","__index","__args"];const qe=e=>(Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)||[])[1];const je=e=>"object"==typeof e?qe(e):qe(e).toLowerCase();const Oe=e=>["number","string","boolean","undefined","Null"].includes(je(e));const Ce=e=>"Array"===je(e);const Be=e=>"Object"===je(e);const Re=e=>Oe(e)||["Array","Object"].includes(je(e));const $e=(e,t)=>{if(!Re(e)||!Re(t))throw new Error(`Unsupported data types for deep equals: ${je(e)} & ${je(t)}`);if(je(e)!==je(t))return!1;if(Oe(e)&&Oe(t))return e===t;const o=(e,t)=>Object.entries(e).every((([e,o])=>$e(t[e],o)));return e&&t&&o(e,t)&&o(t,e)};const Te=e=>{if(Oe(e))return e;if(Ce(e))return e.map(Te);if(Be(e)){const t=Object.keys(e).reduce(((t,o)=>(t[o]=Te(e[o]),t)),{});const o=Object.create(Object.getPrototypeOf(e));return Object.assign(o,t)}throw new Error(`Unsupported data type for clone: ${je(e)}`)};const Ie=(e,t)=>Object.fromEntries(Object.entries(e).map((e=>t(e))));const Ae=(e,t)=>Ie(e,(([e,o])=>[e,t(o)]));const Ee=(e,t)=>Object.fromEntries(Object.entries(e).filter((e=>t(e))));const Pe=(e,t,o,n)=>{if(Oe(e))return e;if(Ce(e))return e.map((e=>Pe(e,t,o,n)));if(Be(e)){e._rev=`${n}/${o}`;const r=t[o];return Object.entries(e).forEach((([o,i])=>{"object"==typeof r&&Object.keys(r).includes(o)&&(e[o]=Pe(i,t,r[o],n))})),e}throw new Error(`Unsupported type ${je(e)} in deep.updateRev`)};const Ke=(e,t)=>{if(Oe(e))return e;if(Ce(e))return e.map((e=>Ke(e,t)));if(Be(e))return e._id=!e._id||e._id.startsWith("__temp__")?e._rev:e._id,e._root=e._root||t,Object.entries(e).forEach((([o,n])=>{e[o]=Ke(n,t)})),e;throw new Error(`Unsupported type ${je(e)} in deep.addId`)};const Le=e=>{if(Oe(e))return e;if(Ce(e))return e.map((e=>Le(e)));if(Be(e)){const t=`__temp__/${Math.random()}`;return e._id=e._id||t,e._rev=e._rev||t,Object.values(e).map((e=>Le(e))),e}throw new Error(`Unsupported type ${je(e)} in addRandomId`)};const Ue=e=>{if(Oe(e))return e;if(Ce(e))return e.map((e=>Ue(e)));if(Be(e))return Ie(e,(([e,t])=>["_owners","_readers"].includes(e)?[e,JSON.stringify(t)]:Oe(t)?[e,t]:[e,Ue(t)]));throw new Error(`Unexpected type ${je(e)} in stringifyOwners`)};const De=e=>(e._owners&&(e._owners=JSON.parse(e._owners)),e._readers&&(e._readers=JSON.parse(e._readers)),e);const Ne=e=>{if(Oe(e))return e;if(Ce(e)||Be(e))return Object.entries(e).reduce(((e,[t,o])=>{const n=Ne(o);return(e=>"Object"===je(e)&&Object.keys(e).every((e=>!Number.isNaN(parseInt(e,10)))))(n)?Object.entries(n).forEach((([o,n])=>{e[`${t}_${o}`]=n})):e[t]=n,e}),{});throw new Error(`Unsupported type ${je(e)} in encodeArraysAsObjects`)};const Me=e=>{const t={[e._id]:Object.entries(e).reduce(((e,[t,o])=>Se.includes(t)?Object.assign(Object.assign({},e),{[t]:o}):Oe(o)?Object.assign(Object.assign({},e),{[`__basic__${t}`]:o}):Object.assign(Object.assign({},e),{[t]:o._id})),{})};return Object.values(e).filter((e=>!Oe(e))).reduce(((e,t)=>Object.assign(Object.assign({},e),Me(t))),t)};const He=e=>Ee(e,(([e])=>!e.startsWith("__basic__")));const Fe=(e,t)=>{const o=e[t];return o.__contains=Object.entries(o).reduce(((t,[o,n])=>["__contains",...Se].includes(o)?t:"__change"===o?"new"===n||"diff"===n||t:Fe(e,n)[n].__contains||t),!1),e};const We=(e,t)=>e.map((e=>Object.entries(e).reduce(((e,[o,n])=>{const r="string"==typeof n&&"undefined"!==je(t[n])?t[n]:n;return Object.assign(Object.assign({},e),{[o]:r})}),{})));class Je{constructor({db:e=new xe}={}){this.db=e}get(e){return x(this,void 0,void 0,(function*(){const{txId:t,outputIndex:o}=ae(e);const{inRevs:n,outData:r}=yield this.db.fromTxId(t);if(!Array.isArray(n)||!Array.isArray(r)||0===r.length)return;const i=r[0].__index||{};const c=r[i.obj].__cls||"";const s=r[i.obj].__func||"";const a=r[i.obj].__args||[];const d=yield Promise.all(Object.values(i).map((e=>{const t=n[e];return t?this.get(t):Promise.resolve({})})));const u=Object.keys(i).map(((e,t)=>[e,d[t]]));const l=Object.fromEntries(u);let p=l.obj;delete l.obj;const h=Object.entries(l).reduce(((e,[t,o])=>{const n=parseInt(t,10);return Number.isNaN(n)||(e[n]=o),e}),[]);const v=function(e,t){let o=0;return t.map((t=>"__"===t?e[o++]:t))}(h,a);let y;if("constructor"===s){const e=S(`(${c})`);p=j(e,v)}else y=q(p[s].bind(p),p,v);Object.entries(i).forEach((([e,o])=>{const n=parseInt(e,10);let i=h[n];"obj"===e?i=p:"res"===e&&(i=y),Pe(i,r,o,t)}));const _=p._root||`${t}/${i.obj}`;return Ke([y,p,...h],_),[...h,p,y][o]}))}}class ze{constructor({db:e=new xe}={}){this.db=e}deploy(e){return x(this,void 0,void 0,(function*(){const[t]=yield this.db.put([{__mdl:e}]);return t}))}static import(e,t){return x(this,void 0,void 0,(function*(){const o=new xe;const n=new Compartment({},{},{resolveHook:e=>e,importHook:e=>x(this,void 0,void 0,(function*(){const[t]=yield o.get([e]);return new c.StaticModuleRecord(t.__mdl,e)}))});const{namespace:r}=yield n.import(t);return r[e]}))}}function Ge(e){return{smartArgs:e.filter((e=>e._rev)),dumbArgs:e.map((e=>e._rev?"__":e))}}class Ye{constructor({db:e=new xe}={}){this.db=e,this.modules=new ze({db:e}),Ye.proxyDepth=Ye.proxyDepth||0}static getUpdate(e){return x(this,void 0,void 0,(function*(){let t;let o;let n;let r;let i;let c;let s;if("Cls"in e){const{Cls:a,rev:d}=e;const u=e.args||[];t=d?(yield ze.import(a,d)).toString():a,o=null;const l=S(`(${t})`);n=j(l,u),r=Te(u),i=u,c=null,s=void 0}else{const{target:a,property:d,args:u}=e;t=null,o=Te(a),n=a,r=Te(u),i=u,c=d,this.proxyDepth+=1,s=q(a[d],a,i),this.proxyDepth-=1}const{smartArgs:a,dumbArgs:d}=Ge(r);const{smartArgs:u}=Ge(i);const l=Object.assign(Object.assign(Object.assign({},a),{obj:o}),{_id:"index"});const p=Object.assign(Object.assign(Object.assign({},u),{obj:n}),{_id:"index"});["Object","Array"].includes(je(s))&&(p.res=s);const[h,v,y]=((e,t)=>{const o=Le(t);const n=o._id;const r=Te(e);const i=Te(o);const c=Ue(r);const s=Ue(i);const a=Ne(c);const d=Ne(s);const u=((e,t)=>Ie(t,(([t,o])=>{const n=e[t];var r;return o.__change=(r=n)?$e(r,o)?"same":"diff":"new",[t,o]})))(Me(a),Me(d));const l=Ae(u,He);const p=Fe(l,n);const h=p[n];delete p[n];const v=Ae(p,(e=>e._rev));const y=(_=e=>e.__contains||Object.values(h).includes(e._id),Ee(p,(([,e])=>_(e))));var _;const g=Object.values(y);const[f,b]=(w=e=>"new"===e.__change,g.reduce((([e,t],o,n)=>w(o)?[[...e,o],t]:[e,[...t,o]]),[[],[]]));var w;const m=[...b,...f];const x=(e=>e.reduce(((e,t,o)=>Object.assign(Object.assign({},e),{[t._id]:o})),{}))(m);const S=We(m,x);const[q]=We([h],x);const j=b.map((e=>e._rev));const[O,...C]=((e,t)=>[t,...e].map((e=>{const t=k(e,["_id","_rev","__change","__contains"]);return Ee(t,(([e,t])=>Se.includes(e)||"number"==typeof t))})))(S,q);return[j,C.map(De).map((e=>Object.entries(e).reduce(((e,[t,o])=>Object.assign(Object.assign({},e),{[t]:v[o]||o})),{}))),O]})(l,p);void 0!==v[0]&&(v[0].__index=y);const _=y.obj;void 0!==v[_]&&(null!==t&&(v[_].__cls=t),v[_].__func=null===c?"constructor":String(c),v[_].__args=d);const g=y.res;return void 0!==v[g]&&"function Object() { [native code] }"!==s.constructor.toString()&&(v[g].__cls=s.constructor.toString()),[h,v,n,u,s,y]}))}allocate(e,t,o){return x(this,void 0,void 0,(function*(){const n=yield Ye.getUpdate({Cls:e,args:t,rev:o});const[r,i,c,s,,a]=n;const[d]=yield this.db.update(r,i);const{txId:u}=ae(d);Object.entries(a).forEach((([e,t])=>{const o=parseInt(e,10);let n=s[o];"obj"===e&&(n=c),Pe(n,i,t,u)}));const l=`${u}/${a.obj}`;return Ke([c,...s],l),c}))}update(e,t,o){return x(this,void 0,void 0,(function*(){const n=yield Ye.getUpdate({target:e,property:t,args:o});const[r,i,,c,s,a]=n;const[d]=yield this.db.update(r,i);const{txId:u}=ae(d);Object.entries(a).forEach((([t,o])=>{const n=parseInt(t,10);let r=c[n];"obj"===t?r=e:t.startsWith("res")&&(r=s),Pe(r,i,o,u)}));const l="string"==typeof e._root?e._root:`${u}/${a.obj}`;return Ke([s,e,...c],l),s}))}get(e,t){return Ye.proxyDepth>0||"function"!=typeof e[t]?Reflect.get(e,t):(...o)=>this.update(e,t,o)}}class Qe{constructor(e={}){this.restClient=new de(e)}get(e,t){return x(this,void 0,void 0,(function*(){return this.restClient.rpc(e,t)}))}}const{crypto:Ve}=e.Bitcoin;class Xe{constructor(e={}){const{chain:t=R,network:o=$,seed:n}=e;if(!["LTC","BTC","DOGE","BCH"].includes(t.toUpperCase()))throw new Error("We currently only support LTC.");if(!["mainnet","testnet","regtest"].includes(o.toLowerCase()))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'");if(void 0!==n)throw new Error('"seed" is deprecated, please use "mnemonic"');this.db=new xe(e),this.modules=new ze({db:this.db}),this.rpc=new Qe(e)}static parseContract(e){const t=e.startsWith("export ")?e.slice(7):e;return t.startsWith("default ")?t.slice(8):t}new(e,t,o){return x(this,void 0,void 0,(function*(){const n=e.toString();const r=Xe.parseContract(n);const i=new Ye({db:this.db});const c=yield i.allocate(r,t,o);return new Proxy(c,i)}))}sync(e){return x(this,void 0,void 0,(function*(){se(e);const{db:t}=this;const o=new Je({db:t});const n=new Ye({db:t});const r=yield o.get(e);return new Proxy(r,n)}))}query({publicKey:t,contract:o}){return x(this,void 0,void 0,(function*(){let n={};if(t&&(n=Object.assign(Object.assign({},n),{publicKey:new e.Bitcoin.PublicKey(t).toString()})),o){const e="string"==typeof o?o:o.toString();n=Object.assign(Object.assign({},n),{classHash:Ve.Hash.sha256(Buffer.from(e)).toString("hex")})}return this.db.wallet.restClient.query(n)}))}idsToRevs(e){return x(this,void 0,void 0,(function*(){return this.db.wallet.restClient.idsToRevs(e)}))}deploy(e){return x(this,void 0,void 0,(function*(){return this.modules.deploy(e)}))}import(e,t){return x(this,void 0,void 0,(function*(){return ze.import(e,t)}))}getChain(){return this.db.wallet.restClient.chain}getNetwork(){return this.db.wallet.restClient.network}getMnemonic(){return this.db.wallet.restClient.mnemonic.toString()}getPrivateKey(){return this.db.wallet.privateKey.toString()}getPublicKey(){return this.db.wallet.publicKey.toString()}getAddress(){return this.db.wallet.address.toString()}getBalance(){return x(this,void 0,void 0,(function*(){return this.db.wallet.getBalance()}))}getUtxos(){return x(this,void 0,void 0,(function*(){const t=new e.Bitcoin.Address(this.getAddress());return this.db.wallet.restClient.getUtxosByAddress(t)}))}broadcast(e){return x(this,void 0,void 0,(function*(){return this.db.wallet.restClient.sendTransaction(e)}))}queryRevs(e){return x(this,void 0,void 0,(function*(){return this.query(e)}))}getOwnedRevs(e=this.db.wallet.publicKey){return this.query({publicKey:e.toString()})}getRevs(e=this.db.wallet.publicKey){return x(this,void 0,void 0,(function*(){return this.query({publicKey:e.toString()})}))}getLatestRevs(e){return x(this,void 0,void 0,(function*(){return this.idsToRevs(e)}))}getLatestRev(e){return x(this,void 0,void 0,(function*(){const[t]=yield this.idsToRevs([e]);return t}))}rpcCall(e,t){return x(this,void 0,void 0,(function*(){const o=yield this.rpc.get(e,t);return o.result?o.result:{}}))}}var Ze=f.default;var et=b.default;var tt=w.default;function ot(e){"string"==typeof e&&(e=function(e){var t=tt.parse(e);var o=t.hostname;var n=parseInt(t.port,10);var r=t.protocol;r=r.substring(0,r.length-1);var i=t.auth.split(":");return{host:o,port:n,protocol:r,user:i[0]?decodeURIComponent(i[0]):null,pass:i[1]?decodeURIComponent(i[1]):null}}(e)),e=e||{},this.host=e.host||"127.0.0.1",this.port=e.port||8332,this.user=e.user||"user",this.pass=e.pass||"pass",this.protocol="http"===e.protocol?Ze:et,this.batchedCalls=null,this.disableAgent=e.disableAgent||!1;var t=void 0!==e.rejectUnauthorized;this.rejectUnauthorized=!t||e.rejectUnauthorized,ot.config.log?this.log=ot.config.log:this.log=ot.loggers[ot.config.logger||"normal"]}var nt=console.log.bind(console);var rt=function(){};function ct(e,t){var o=this;e=JSON.stringify(e);var n=this.user+":"+this.pass;var r=Buffer.from&&Buffer.from!==Uint8Array.from?Buffer.from(n):new Buffer(n);this.auth=r.toString("base64");var i={host:o.host,path:"/",method:"POST",port:o.port,rejectUnauthorized:o.rejectUnauthorized,agent:!o.disableAgent&&void 0};if(o.httpOptions)for(var c in o.httpOptions)i[c]=o.httpOptions[c];var s=!1;var a="Bitcoin JSON-RPC: ";var d=this.protocol.request(i,(function(e){var n="";e.on("data",(function(e){n+=e})),e.on("end",(function(){if(!s)if(s=!0,401!==e.statusCode)if(403!==e.statusCode){if(500===e.statusCode&&"Work queue depth exceeded"===n.toString("utf8")){var r=new Error("Bitcoin JSON-RPC: "+n.toString("utf8"));return r.code=429,void t(r)}var i;try{i=JSON.parse(n)}catch(r){o.log.err(r.stack),o.log.err(n),o.log.err("HTTP Status code:"+e.statusCode);var c=new Error(a+"Error Parsing JSON: "+r.message);return void t(c)}t(i.error,i)}else t(new Error(a+"Connection Rejected: 403 Forbidden"));else t(new Error(a+"Connection Rejected: 401 Unnauthorized"))}))}));d.on("error",(function(e){var o=new Error(a+"Request Error: "+e.message);s||(s=!0,t(o))})),d.setHeader("Content-Length",e.length),d.setHeader("Content-Type","application/json"),d.setHeader("Authorization","Basic "+o.auth),d.write(e),d.end()}ot.loggers={none:{info:rt,warn:rt,err:rt,debug:rt},normal:{info:nt,warn:nt,err:nt,debug:rt},debug:{info:nt,warn:nt,err:nt,debug:nt}},ot.config={logger:"normal"},ot.prototype.batch=function(e,t){this.batchedCalls=[],e(),ct.call(this,this.batchedCalls,t),this.batchedCalls=null},ot.callspec={abandonTransaction:"str",abortRescan:"",addMultiSigAddress:"",addNode:"",analyzePSBT:"str",backupWallet:"",bumpFee:"str",clearBanned:"",combinePSBT:"obj",combineRawTransaction:"obj",convertToPSBT:"str",createMultiSig:"",createPSBT:"obj",createRawTransaction:"obj obj",createWallet:"str",decodePSBT:"str",decodeScript:"str",decodeRawTransaction:"",deriveAddresses:"str",disconnectNode:"",dumpPrivKey:"",dumpWallet:"str",encryptWallet:"",enumerateSigners:"",estimateFee:"",estimateSmartFee:"int str",estimatePriority:"int",generate:"int",generateBlock:"str obj",generateToAddress:"int str",generateToDescriptor:"int str",getAccount:"",getAccountAddress:"str",getAddedNodeInfo:"",getAddressMempool:"obj",getAddressUtxos:"obj",getAddressBalance:"obj",getAddressDeltas:"obj",getAddressesByLabel:"str",getAddressInfo:"str",getAddressTxids:"obj",getAddressesByAccount:"",getBalance:"str int",getBalances:"",getBestBlockHash:"",getBlockDeltas:"str",getBlock:"str int",getBlockchainInfo:"",getBlockCount:"",getBlockFilter:"str",getBlockHashes:"int int obj",getBlockHash:"int",getBlockHeader:"str",getBlockNumber:"",getBlockStats:"str",getBlockTemplate:"",getConnectionCount:"",getChainTips:"",getChainTxStats:"",getDescriptorInfo:"str",getDifficulty:"",getGenerate:"",getHashesPerSec:"",getIndexInfo:"",getInfo:"",getMemoryInfo:"",getMemoryPool:"",getMemPoolAncestors:"str",getMemPoolDescendants:"str",getMemPoolEntry:"str",getMemPoolInfo:"",getMiningInfo:"",getNetTotals:"",getNetworkHashPS:"",getNetworkInfo:"",getNewAddress:"str str",getNodeAddresses:"",getPeerInfo:"",getRawChangeAddress:"",getRawMemPool:"bool",getRawTransaction:"str int",getReceivedByAccount:"str int",getReceivedByAddress:"str int",getReceivedByLabel:"str",getRpcInfo:"",getSpentInfo:"obj",getTransaction:"",getTxOut:"str int bool",getTxOutProof:"",getTxOutSetInfo:"",getUnconfirmedBalance:"",getWalletInfo:"",getWork:"",getZmqNotifications:"",finalizePSBT:"str",fundRawTransaction:"str",help:"",importAddress:"str str bool",importDescriptors:"str",importMulti:"obj obj",importPrivKey:"str str bool",importPrunedFunds:"str, str",importPubKey:"str",importWallet:"str",invalidateBlock:"str",joinPSBTs:"obj",keyPoolRefill:"",listAccounts:"int",listAddressGroupings:"",listBanned:"",listDescriptors:"",listLabels:"",listLockUnspent:"bool",listReceivedByAccount:"int bool",listReceivedByAddress:"int bool",listReceivedByLabel:"",listSinceBlock:"str int",listTransactions:"str int int",listUnspent:"int int",listWalletDir:"",listWallets:"",loadWallet:"str",lockUnspent:"",logging:"",move:"str str float int str",ping:"",preciousBlock:"str",prioritiseTransaction:"str float int",pruneBlockChain:"int",psbtBumpFee:"str",removePrunedFunds:"str",reScanBlockChain:"",saveMemPool:"",send:"obj",setHDSeed:"",setLabel:"str str",setWalletFlag:"str",scanTxOutSet:"str",sendFrom:"str str float int str str",sendMany:"str obj int str",sendRawTransaction:"str",sendToAddress:"str float str str",setAccount:"",setBan:"str str",setNetworkActive:"bool",setGenerate:"bool int",setTxFee:"float",signMessage:"",signMessageWithPrivKey:"str str",signRawTransaction:"",signRawTransactionWithKey:"str obj",signRawTransactionWithWallet:"str",stop:"",submitBlock:"str",submitHeader:"str",testMemPoolAccept:"obj",unloadWallet:"",upgradeWallet:"",uptime:"",utxoUpdatePSBT:"str",validateAddress:"",verifyChain:"",verifyMessage:"",verifyTxOutProof:"str",walletCreateFundedPSBT:"",walletDisplayAddress:"str",walletLock:"",walletPassPhrase:"string int",walletPassphraseChange:"",walletProcessPSBT:"str"};var st=function(e,t,o){return Array.prototype.slice.call(e,t,o)};function at(){return parseInt(1e5*Math.random())}!function(e,t,o){function n(e,t){return function(){var n=arguments.length-1;this.batchedCalls&&(n=arguments.length);for(var r=0;r<n;r++)t[r]&&(arguments[r]=t[r](arguments[r]));this.batchedCalls?this.batchedCalls.push({jsonrpc:"2.0",method:e,params:st(arguments),id:at()}):o.call(this,{method:e,params:st(arguments,0,arguments.length-1),id:at()},arguments[arguments.length-1])}}var r={str:function(e){return e.toString()},int:function(e){return parseFloat(e)},float:function(e){return parseFloat(e)},bool:function(e){return!0===e||"1"==e||"true"==e||"true"==e.toString().toLowerCase()},obj:function(e){return"string"==typeof e?JSON.parse(e):e}};for(var i in t){var c=[];if(t[i].length){c=t[i].split(" ");for(var s=0;s<c.length;s++)r[c[s]]?c[s]=r[c[s]]:c[s]=r.str}var a=i.toLowerCase();e.prototype[i]=n(a,c),e.prototype[a]=e.prototype[i]}}(ot,ot.callspec,ct);var dt=ot;const ut=new dt({protocol:process.env.RPC_PROTOCOL,user:process.env.RPC_USER,pass:process.env.RPC_PASSWORD,host:process.env.RPC_HOST,port:process.env.RPC_PORT});const lt={createwallet:m.default.promisify(dt.prototype.createwallet.bind(ut)),getaddressinfo:m.default.promisify(dt.prototype.getaddressinfo.bind(ut)),getBlock:m.default.promisify(dt.prototype.getBlock.bind(ut)),getBlockchainInfo:m.default.promisify(dt.prototype.getBlockchainInfo.bind(ut)),getBlockHash:m.default.promisify(dt.prototype.getBlockHash.bind(ut)),generateToAddress:m.default.promisify(dt.prototype.generateToAddress.bind(ut)),getRawTransaction:m.default.promisify(dt.prototype.getRawTransaction.bind(ut)),importaddress:m.default.promisify(dt.prototype.importaddress.bind(ut)),listunspent:m.default.promisify(dt.prototype.listunspent.bind(ut)),sendRawTransaction:m.default.promisify(dt.prototype.sendRawTransaction.bind(ut))};const{Opcode:pt,Script:ht,Mnemonic:vt,crypto:yt,Transaction:_t,encoding:gt}=e.Bitcoin;function ft(e=0){return"travel upgrade inside soda birth essence junk merit never twenty system opinion;toddler hockey salute wheel harvest video narrow riot guitar lake sea call;cannon hour begin test replace fury motion squirrel envelope announce neck culture".split(";")[e]}function bt(e=0){return new Xe(function(e=0){return{mnemonic:ft(),chain:R,network:$,path:ee({account:e})}}(e))}const wt=({random:e=!1}={})=>x(void 0,void 0,void 0,(function*(){const t=e?ee():X();const o=function(e=0){return new vt(ft(e))}();const n=new ke({mnemonic:o,path:t});return yield s.backOff((()=>x(void 0,void 0,void 0,(function*(){return(e=>x(void 0,void 0,void 0,(function*(){const{result:t}=yield lt.generateToAddress(1,e.address);const{result:o}=yield lt.getBlock(t[0],2);if(o.confirmations<=0)throw new Error(`No confirmations on block mining: ${o.confirmations}`)})))(n)})))),t}));function mt(e,o){const n=Object.keys(o);const r=Object.keys(e);if(n.length!==r.length)throw new Error("Actual keys do not match expected keys");n.forEach((n=>{const r=e[n];const i=o[n];if(void 0===i)throw new Error(`${n} is not defined in expected object`);if("value"===i.check)t.expect(e).to.have.property(n),t.expect(e[n]).to.deep.eq(i.value);else{if("type"!==i.check)throw new Error("Error configuring expectToEqual: set 'check' to 'type' or 'value'");if("string"===i.type)t.expect(e).to.have.property(n).that.is.a("string");else if("number"===i.type)t.expect(e).to.have.property(n).that.is.a("number");else if("array"===i.type){if(t.expect(e).to.have.property(n).that.is.a("array").that.have.lengthOf(i.length),void 0!==i.length&&i.length>0)for(let e=0;e<r.length;e+=1)t.expect(r[e]).to.be.an(i.subtype)}else{if("object"!==i.type)throw new Error("Error configuring expectToEqual: set 'type' to 'number', 'string', array', or 'object'.");t.expect(e).to.have.property(n).that.is.an("object")}}}))}const kt=e=>e.split("/")[0];const xt=ft();const St=e=>{const[t,o]=e.split("/");const n=parseFloat(o);return[64,65].includes(t.length)&&!Number.isNaN(n)&&Number.isFinite(n)};let qt=[];before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){qt=yield function({n:e=1,random:t=!1}={}){return x(this,void 0,void 0,(function*(){const o=[];for(let n=0;n<e;n+=1)o.push(yield wt({random:t}));return yield x(void 0,void 0,void 0,(function*(){let e=!1;do{try{const{result:t}=yield lt.generateToAddress(100,(new vt).toHDPrivateKey("",$).derive(X(R,$)).privateKey.toPublicKey().toAddress());e=100===t.length}catch(e){Y(500)}}while(!e)})),o}))}({n:58,random:!0})}))));let jt=0;function Ot(){if(jt+=1,qt.length)return qt.pop();throw Error(`No more paths ${jt}`)}describe("Computer",(()=>{describe("New",(()=>{describe("Should create a smart object without argument",(()=>{class e{constructor(){this.n=1}}let o;let n;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){n=new Xe({mnemonic:xt,path:Ot()}),r=new Xe({mnemonic:xt,path:Ot()}),({db:i}=n),o=yield n.new(e)})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o._id).eq(o._root),t.expect(St(o._id)),t.expect(St(o._rev)),t.expect(St(o._root))})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:i});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);t.expect(n).to.be.an("array").that.have.lengthOf(1),mt(n[0],{__func:{check:"value",value:"constructor",type:"string"},__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I,type:"number"}}),t.expect(n[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("should work with idsToRevs",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield n.idsToRevs([o._id])).to.deep.eq([o._rev])})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)})))),it("Should be able to call the RPC methods",(()=>x(void 0,void 0,void 0,(function*(){yield n.rpcCall("getBlockchainInfo","")}))))})),describe("Should create a smart object with a dumb argument",(()=>{class e{constructor(e){this.n=e}}let o;const n=Math.random();let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),i=new Xe({mnemonic:xt,path:Ot()}),({db:c}=r),o=yield r.new(e,[n])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"value",type:"number",value:n},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o._id).eq(o._root),t.expect(St(o._id)),t.expect(St(o._rev)),t.expect(St(o._root))})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor",type:"string"},__args:{check:"type",type:"array",length:1,subtype:"number"},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I,type:"number"}}),t.expect(r[0].__args).to.deep.eq([n]),t.expect(r[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with a smart argument",(()=>{class e{constructor(){this.n=1}}class o{constructor(e){this.a=e}}let n;let r;let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){i=new Xe({mnemonic:xt,path:Ot()}),c=new Xe({mnemonic:xt,path:Ot()}),({db:s}=i),n=yield i.new(e,[]),r=yield i.new(o,[n])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){mt(n,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r.a,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),t.expect(r.a).to.deep.eq(n)})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(St(n._id)),t.expect(St(n._rev)),t.expect(St(n._root)),t.expect(St(r._id)),t.expect(St(r._rev)),t.expect(St(r._root));const e=kt(n._id);const o=kt(r._id);t.expect(e).not.eq(o),t.expect(n._id).eq(`${e}/0`),t.expect(n._rev).eq(`${o}/0`),t.expect(r._id).eq(`${o}/1`),t.expect(r._rev).eq(`${o}/1`),t.expect(r.a._id).eq(n._id),t.expect(r.a._rev).eq(n._rev),t.expect(n._root).eq(n._id),t.expect(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:s});t.expect(yield e.get(n._rev)).to.deep.eq(n),t.expect(yield e.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const i=yield s.get([n._id]);t.expect(i).to.be.an("array").that.have.lengthOf(1),mt(i[0],{__func:{check:"value",value:"constructor",type:"string"},__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I,type:"number"}}),t.expect(i[0].__index).to.deep.eq({obj:0});const c=kt(r._id);const a=yield s.get([`${c}/0`,`${c}/1`]);t.expect(a).to.be.an("array").that.have.lengthOf(2),mt(a[0],{__index:{check:"type",type:"object"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I,type:"number"}}),t.expect(a[0].__index).to.deep.eq({0:0,obj:1}),mt(a[1],{a:{check:"value",value:0},__func:{check:"value",value:"constructor"},__args:{check:"value",value:["__"]},__cls:{check:"value",value:o.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.getLatestRev(r._id)).eq(r._rev),t.expect(yield i.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with idsToRevs",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.idsToRevs([n._id])).to.deep.eq([n._rev]),t.expect(yield i.idsToRevs([r._id])).to.deep.eq([r._rev])})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield c.sync(n._rev)).to.deep.eq(n),t.expect(yield c.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should create a smart object with a sub-object",(()=>{class e{constructor(){this.n={m:1}}}let o;let n;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){n=new Xe({mnemonic:xt,path:Ot()}),r=new Xe({mnemonic:xt,path:Ot()}),({db:i}=n),o=yield n.new(e,[])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(o.n,{m:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o.n._id).eq(o.n._rev),t.expect(o._root).eq(o._id),t.expect(o.n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:i});const n=yield e.get(o._rev);t.expect(n).to.deep.eq(o),t.expect(o.n._id.startsWith("__temp__")).eq(!1),t.expect(o.n._rev.startsWith("__temp__")).eq(!1);const r=yield e.get(o.n._rev);t.expect(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);t.expect(n).to.be.an("array").that.have.lengthOf(1),mt(n[0],{n:{check:"value",value:1},__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with a smart sub-object",(()=>{class e{constructor(t){this.b=t?new e(!1):void 0}}let o;let n;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){n=new Xe({mnemonic:xt,path:Ot()}),r=new Xe({mnemonic:xt,path:Ot()}),({db:i}=n),o=yield n.new(e,[!0])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(o.b,{b:{check:"value",value:void 0},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o.b._id).eq(o.b._rev),t.expect(o._root).eq(o._id),t.expect(o.b._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:i});const n=yield e.get(o._rev);t.expect(n).to.deep.eq(o),t.expect(o.b._id.startsWith("__temp__")).eq(!1),t.expect(o.b._rev.startsWith("__temp__")).eq(!1);const r=yield e.get(o.b._rev);t.expect(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);t.expect(n).to.be.an("array").that.have.lengthOf(1),mt(n[0],{b:{check:"value",value:1},__func:{check:"value",value:"constructor"},__args:{check:"value",value:[!0]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with an owner defined",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let o;const n=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),i=new Xe({mnemonic:xt,path:Ot()}),({db:c}=r),s=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,s])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"value",value:n},_owners:{check:"value",value:[s]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o._id).eq(o._root),t.expect(St(o._id)),t.expect(St(o._rev)),t.expect(St(o._root))})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n,s]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create an encrypted smart object",(()=>{class e{constructor(e,t){this.n=e,this._readers=[t]}}let o;const n=Math.random();let r;let i;let c;let s;let a;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),i=new Xe({mnemonic:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:Ot()}),({db:c}=r),({db:s}=i),a=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,a])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"value",value:n},_readers:{check:"value",value:[a]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o._id).eq(o._root),t.expect(St(o._id)),t.expect(St(o._rev)),t.expect(St(o._root))})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with encoded data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should be able to decode the output when db has access",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should be not able to decode the output when db does not has access",(()=>x(void 0,void 0,void 0,(function*(){try{yield s.get([o._rev])}catch(e){t.expect(e).to.be.instanceof(Error),t.expect(e).to.have.property("message","Decryption failure")}})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o);try{yield i.sync(o._rev),t.expect(!0).eq(!1)}catch(e){t.expect(e.message).eq("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should create an off-chain object",(()=>{class e{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}}let o;const n=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),i=new Xe({mnemonic:xt,path:Ot()}),({db:c}=r),({db:s}=i),o=yield r.new(e,[n])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"value",value:n},_url:{check:"value",value:"http://127.0.0.1:3000"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with encoded data data",(()=>x(void 0,void 0,void 0,(function*(){const i=o._rev.split("/")[0];const{restClient:c}=r.db.wallet;const s=yield me.fromTxId({txId:i,restClient:c});const{outData:a}=s;t.expect(a).to.be.an("array").that.have.lengthOf(1),mt(a[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"type",type:"string"}})})))),it("Should be able to get the output from the server when db has access",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should give all users access to the server",(()=>x(void 0,void 0,void 0,(function*(){const r=yield s.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work if the contract is a string",(()=>{let e=null;let o;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){o=new Xe({mnemonic:xt,path:Ot()}),e=yield o.new("class A {\n        constructor(n) {\n          this.n = n\n        }\n      }",[1])})))),it("should work",(()=>{t.expect(e).to.not.be.undefined,t.expect(typeof e).eq("object"),mt(e,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),t.expect(e._id).eq(e._rev)})),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){const o=bt();t.expect(yield o.sync(e._rev)).to.deep.eq(e)}))))})),describe("Should not create a smart object if no args as passed to the constructor",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let o;it("Should throw an error",(()=>x(void 0,void 0,void 0,(function*(){try{const n=new Xe;o=o||(yield n.new(e,[])),t.expect(!0).eq(!1)}catch(e){t.expect(o).to.be.undefined,t.expect(e.message).to.not.be.undefined}}))))}))})),describe("Function calls",(()=>{describe("Should work for a function call with a dumb argument",(()=>{class e{constructor(e){this.n=e}inc(e){return this.n+=e,this.n}}let o;let n;let r;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){const t=new Xe({mnemonic:xt,path:Ot()});r=new Xe({mnemonic:xt,path:Ot()}),({db:n}=t),o=yield t.new(e,[1]),yield o.inc(1)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(St(o._id)).eq(!0),t.expect(St(o._rev)).eq(!0),t.expect(St(o._root)).eq(!0),t.expect(o._id).not.eq(o._rev),t.expect(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:n});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield n.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const i=yield n.get([o._rev]);t.expect(i).to.be.an("array").that.have.lengthOf(1),mt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){const e=new Xe;t.expect(yield e.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function call on an encrypted object",(()=>{class e{constructor(e,t){this.n=e,this._readers=[t]}inc(e){return this.n+=e,this.n}}let o;const n=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),i=new Xe({mnemonic:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:Ot()}),({db:c}=r),s=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,s]),yield o.inc(1)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_readers:{check:"value",value:[s]}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(St(o._id)).eq(!0),t.expect(St(o._rev)).eq(!0),t.expect(St(o._root)).eq(!0),t.expect(o._id).not.eq(o._rev),t.expect(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n,s]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_readers:{check:"value",value:[]}});const i=yield c.get([o._rev]);t.expect(i).to.be.an("array").that.have.lengthOf(1),mt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_readers:{check:"value",value:[]}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o);try{yield i.sync(o._rev),t.expect(!0).eq(!1)}catch(e){t.expect(e.message).eq("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should work for a function call on an off chain object",(()=>{class e{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}inc(e){return this.n+=e,this.n}}let o;const n=Math.random();let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),i=new Xe({mnemonic:xt,path:Ot()}),({db:c}=r),o=yield r.new(e,[n]),yield o.inc(1)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(St(o._id)).eq(!0),t.expect(St(o._rev)).eq(!0),t.expect(St(o._root)).eq(!0),t.expect(o._id).not.eq(o._rev),t.expect(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"value",value:"http://127.0.0.1:3000"}});const i=yield c.get([o._rev]);t.expect(i).to.be.an("array").that.have.lengthOf(1),mt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function with a smart argument",(()=>{class e{constructor(){this.n=1}}class o{constructor(){this.m=2}objInc(e){return e.n+=1,this.m+=e.n,this.m}}let n;let r;let i;let c;let s;let a;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){c=new Xe({mnemonic:xt,path:Ot()}),s=new Xe({mnemonic:xt,path:Ot()}),a=c.db,n=yield c.new(e,[]),r=yield c.new(o,[]),i=yield r.objInc(n)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(n,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r,{m:{check:"value",value:4},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the correct value",(()=>{t.expect(i).eq(4)})),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(St(n._id)).eq(!0),t.expect(St(n._rev)).eq(!0),t.expect(St(n._root)).eq(!0),t.expect(St(r._id)).eq(!0),t.expect(St(r._rev)).eq(!0),t.expect(St(r._root)).eq(!0);const e=kt(n._id);const o=kt(r._id);const i=kt(r._rev);t.expect(e).not.eq(o),t.expect(o).not.eq(i),t.expect(i).not.eq(e),t.expect(n._id).eq(`${e}/0`),t.expect(r._id).eq(`${o}/0`),t.expect(n._rev).eq(`${i}/0`),t.expect(r._rev).eq(`${i}/1`),t.expect(n._root).eq(n._id),t.expect(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:a});t.expect(yield e.get(n._rev)).to.deep.eq(n),t.expect(yield e.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const i=yield a.get([n._id]);t.expect(i).to.be.an("array").that.have.lengthOf(1),mt(i[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__cls:{check:"value",value:e.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const c=kt(r._id);const s=yield a.get([`${c}/0`]);t.expect(s).to.be.an("array").that.have.lengthOf(1),mt(s[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__cls:{check:"value",value:o.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const d=kt(r._rev);const u=yield a.get([`${d}/0`,`${d}/1`]);t.expect(u).to.be.an("array").that.have.lengthOf(2),mt(u[0],{__index:{check:"value",value:{obj:1,0:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),mt(u[1],{__func:{check:"value",value:"objInc"},__args:{check:"value",value:["__"]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield c.getLatestRev(n._id)).eq(n._rev),t.expect(yield c.getLatestRev(r._id)).eq(r._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield s.sync(n._rev)).to.deep.eq(n),t.expect(yield s.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should work for a function that returns a dumb object",(()=>{class e{getJson(){return{n:1}}}let o;let n;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),i=new Xe({mnemonic:xt,path:Ot()}),({db:c}=r),o=yield r.new(e,[]),n=n||(yield o.getJson(3))})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(n,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(St(o._id)).eq(!0),t.expect(St(o._rev)).eq(!0),t.expect(St(o._root)).eq(!0),t.expect(St(n._id)).eq(!0),t.expect(St(n._rev)).eq(!0),t.expect(St(n._root)).eq(!0);const e=kt(o._id);const r=kt(n._id);t.expect(e).not.eq(r),t.expect(o._id).eq(`${e}/0`),t.expect(n._id).eq(`${r}/1`),t.expect(o._rev).eq(`${r}/0`),t.expect(n._rev).eq(`${r}/1`),t.expect(o._root).eq(o._id),t.expect(n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o),t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const i=kt(n._id);const s=yield c.get([`${i}/0`,`${i}/1`]);t.expect(s).to.be.an("array").that.have.lengthOf(2),mt(s[0],{__func:{check:"value",value:"getJson"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),mt(s[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev),t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o),t.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function that returns a smart object",(()=>{class e{constructor(e){this.n=e}send(t){if(t>this.n)throw new Error;return this.n-=t,new e(t)}}let o;let n;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),i=new Xe({mnemonic:xt,path:Ot()}),({db:c}=r),o=yield r.new(e,[10]),n=yield o.send(3)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"value",value:7},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(n,{n:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(St(o._id)).eq(!0),t.expect(St(o._rev)).eq(!0),t.expect(St(o._root)).eq(!0),t.expect(St(n._id)).eq(!0),t.expect(St(n._rev)).eq(!0),t.expect(St(n._root)).eq(!0);const e=kt(o._id);const r=kt(n._id);t.expect(e).not.eq(r),t.expect(o._id).eq(`${e}/0`),t.expect(n._id).eq(`${r}/1`),t.expect(o._rev).eq(`${r}/0`),t.expect(n._rev).eq(`${r}/1`),t.expect(o._root).eq(o._id),t.expect(n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o),t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),mt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[10]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const i=kt(n._id);const s=yield c.get([`${i}/0`,`${i}/1`]);t.expect(s).to.be.an("array").that.have.lengthOf(2),mt(s[0],{__func:{check:"value",value:"send"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),mt(s[1],{__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev),t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o),t.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function that updates a nested object",(()=>{class e{constructor(){this.a={aa:1},this.b={bb:2}}update(){this.b.bb=3}}let o;let n;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){n=new Xe({mnemonic:xt,path:Ot()}),r=new Xe({mnemonic:xt,path:Ot()}),({db:i}=n),o=yield n.new(e,[]),yield o.update()})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{a:{check:"type",type:"object"},b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(o.a,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(o.b,{bb:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(St(o._id)).eq(!0),t.expect(St(o._rev)).eq(!0),t.expect(St(o._root)).eq(!0),t.expect(St(o.a._id)).eq(!0),t.expect(St(o.a._rev)).eq(!0),t.expect(St(o.a._root)).eq(!0),t.expect(St(o.b._id)).eq(!0),t.expect(St(o.b._rev)).eq(!0),t.expect(St(o.b._root)).eq(!0);const e=kt(o._id);t.expect(o._id).eq(`${e}/0`),t.expect(o.a._id).eq(`${e}/1`),t.expect(o.b._id).eq(`${e}/2`),t.expect(o._root).eq(o._id),t.expect(o.a._root).eq(o._id),t.expect(o.b._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:i});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const n=yield i.get([o._id,o.a._id,o.b._id]);t.expect(n).to.be.an("array").that.have.lengthOf(3),mt(n[0],{a:{check:"value",value:1},b:{check:"value",value:2},__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),mt(n[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),mt(n[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const r=yield i.get([o._rev,o.a._rev,o.b._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(3),mt(r[0],{b:{check:"value",value:1},__func:{check:"value",value:"update"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),mt(r[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),mt(r[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function that returns an array",(()=>{class e{constructor(){this.aa=1}createArray(){return this.a=new e,[new e,new e]}}let t;let o;let n;let r;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),t=yield r.new(e,[]),[o,n]=yield t.createArray()})))),it("Should return an array",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(n,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped as object",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return{o:this.a.f()}}}let o;let n;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){c=new Xe({mnemonic:xt,path:Ot()}),o=yield c.new(e,[]),r=yield c.new(t,[o]),n=yield r.g(),({o:i}=yield r.o())})))),it("Should return the object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped in an array",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f()]}}let o;let n;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){c=new Xe({mnemonic:xt,path:Ot()}),o=yield c.new(e,[]),r=yield c.new(t,[o]),n=yield r.g(),[i]=yield r.o()})))),it("Should return the object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns multiple objects created by a property wrapped in an array",(()=>{class e{f(){return new e}}class o{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f(),this.a.f()]}}let n;let r;let i;let c;let s;let a;let d;let u;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){a=new Xe({mnemonic:xt,path:Ot()}),d=new Xe({mnemonic:xt,path:Ot()}),({db:u}=a),n=yield a.new(e,[]),i=yield a.new(o,[n]),r=yield i.g(),[c,s]=yield i.o()})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(c,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(s,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(i,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(i.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){const e=[n,r,c,s,i];for(let o=0;o<e.length;o+=1){const n=e[o];t.expect(St(n._id)).eq(!0),t.expect(St(n._rev)).eq(!0),t.expect(St(n._root)).eq(!0)}t.expect(n._id).not.eq(n._rev),t.expect(i._id).not.eq(i._rev),t.expect(r._id).eq(r._rev)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:u});t.expect(yield e.get(n._rev)).to.deep.eq(n),t.expect(yield e.get(r._rev)).to.deep.eq(r),t.expect(yield e.get(i._rev)).to.deep.eq(i)})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield a.getLatestRev(n._id)).eq(n._rev),t.expect(yield a.getLatestRev(r._id)).eq(r._rev),t.expect(yield a.getLatestRev(i._id)).eq(i._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield d.sync(n._rev)).to.deep.eq(n),t.expect(yield d.sync(r._rev)).to.deep.eq(r),t.expect(yield d.sync(i._rev)).to.deep.eq(i)}))))})),describe("Should work for a function that returns multiple objects created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return this.a.f()}}let o;let n;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){c=new Xe({mnemonic:xt,path:Ot()}),o=yield c.new(e,[]),r=yield c.new(t,[o]),n=yield r.g(),i=yield r.o()})))),it("Should return the object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}}let o;let n;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){i=new Xe({mnemonic:xt,path:Ot()}),o=yield i.new(e,[]),r=yield i.new(t,[o]),n=yield r.g()})))),it("Should return the object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work when setting an owner",(()=>{class e{constructor(e){this._owners=[e]}updateOwner(e){this._owners=[e]}}let o;const n=new Xe({chain:R,network:$});const r=n.db.wallet.publicKey.toString();let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){i=new Xe({mnemonic:xt,path:Ot()}),s=i.db.wallet.publicKey.toString(),({db:c}=i),o=yield i.new(e,[s]),yield o.updateOwner(r)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{_owners:{check:"value",value:[r]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){const e=kt(o._id);t.expect(o._id).eq(`${e}/0`)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new Je({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const[n]=yield c.get([o._id]);t.expect(n).to.deep.eq({__func:"constructor",__args:[s],__index:{obj:0},__cls:e.toString(),_amount:I,_owners:[s]});const[i]=yield c.get([o._rev]);t.expect(i).to.deep.eq({__func:"updateOwner",__args:[r],__index:{obj:0},_owners:[r],_amount:I})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield n.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work with multiple computers",(()=>{class e{constructor(){this.n=1}inc(){this.n+=1}}let t=null;let o=null;let n;let r;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){n=new Xe({mnemonic:xt,path:Ot()}),r=new Xe({mnemonic:xt,path:Ot()}),t=yield n.new(e,[]),o=yield r.new(e,[]),yield t.inc()})))),it("should work",(()=>{mt(t,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),mt(o,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))}))})),describe("sync",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let o;const n=Math.random();let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({path:Ot(),mnemonic:xt}),i=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,i])})))),it("Should create another instance of the same smart object",(()=>x(void 0,void 0,void 0,(function*(){mt(o,{n:{check:"value",value:n},_owners:{check:"value",value:[i]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}});const e=bt();const r=yield e.sync(o._rev);t.expect(r).to.deep.eq(o)})))),it("throw an error if no params are passed to sync function",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync(),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: undefined")}})))),it("throw an error if rev is not in the right format: tdId:num",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync("123"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 123")}})))),it("throw an error if trId in rev is not 64 hex characters",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync("123:0"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 123:0")}})))),it("throw an error if trId in rev is contains non hex characters",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0")}})))),it("throw an error if num in rev is not a number",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc")}}))))})),describe("getBalance",(()=>{it("Should return the network",(()=>x(void 0,void 0,void 0,(function*(){const e=new Xe;t.expect(typeof(yield e.getBalance())).to.eq("number")}))))})),describe.skip("Query",(()=>{class o{constructor(){this.n=1}}let n;let r;it("Should work with a string encoded public key",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),n=yield r.new(o);const e=r.getPublicKey();const i=yield r.query({publicKey:e});t.expect(i.length).to.eq(1);const[c]=i;t.expect(typeof c).to.eq("string"),t.expect(c).to.eq(n._rev)})))),it("Should work with a public key",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),n=yield r.new(o);const i=r.getPublicKey();const c=yield r.query({publicKey:new e.Bitcoin.PublicKey(i)});t.expect(c.length).to.eq(1);const[s]=c;t.expect(typeof s).to.eq("string"),t.expect(s).to.eq(n._rev)})))),it("Should work with a class",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),n=yield r.new(o);const e=yield r.query({contract:o});t.expect(e.length).to.be.above(1);const[i]=e;t.expect(typeof i).to.eq("string"),t.expect(e.includes(n._rev)).to.be.true})))),it("Should work with a class string",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),n=yield r.new(o);const e=yield r.query({contract:o.toString()});t.expect(e.length).to.be.above(1);const[i]=e;t.expect(typeof i).to.eq("string"),t.expect(e.includes(n._rev)).to.be.true})))),it("Should work with a class and a public key",(()=>x(void 0,void 0,void 0,(function*(){r=new Xe({mnemonic:xt,path:Ot()}),n=yield r.new(o);const e=r.getPublicKey();const i=yield r.query({contract:o,publicKey:e});t.expect(i.length).to.eq(1);const[c]=i;t.expect(typeof c).to.eq("string"),t.expect(c).to.eq(n._rev)}))))})),describe("Deploy",(()=>{describe("Should create a smart object from a deployed module",(()=>x(void 0,void 0,void 0,(function*(){let e;let o;let n;let r;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){o=new Xe({mnemonic:xt,path:Ot()}),n=new Xe({mnemonic:xt,path:Ot()}),({db:r}=o);const t=yield o.deploy("export class A {\n        constructor() {\n          this.n = 1\n        }\n      }");e=yield o.new("A",[],t)})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){mt(e,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(e._id).eq(e._rev),t.expect(e._id).eq(e._root),t.expect(St(e._id)),t.expect(St(e._rev)),t.expect(St(e._root))})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const o=new Je({db:r});t.expect(yield o.get(e._rev)).to.deep.eq(e)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const o=yield r.get([e._rev]);t.expect(o).to.be.an("array").that.have.lengthOf(1),t.expect(o[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield o.getLatestRev(e._id)).eq(e._rev)})))),it("should work with idsToRevs",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield o.idsToRevs([e._id])).to.deep.eq([e._rev])})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield n.sync(e._rev)).to.deep.eq(e)})))),it("Should be able to call the RPC methods",(()=>x(void 0,void 0,void 0,(function*(){yield o.rpcCall("getBlockchainInfo","")}))))}))))}))}));

import{backOff as t}from"exponential-backoff";import{Computer as e}from"@bitcoin-computer/lib";import s from"dotenv";import n from"fs";import{format as a,createLogger as r,transports as o}from"winston";import i from"bitcoind-rpc";import c from"util";import l from"pg-promise";import d from"pg-monitor";import p from"@bitcoin-computer/bitcore-lib-ltc";s.config();const y=JSON.parse(n.readFileSync("package.json","utf8"));const{PORT:u,ZMQ_URL:m,CHAIN:g,NETWORK:S,BCN_ENV:h,BCN_URL:f,DEBUG_MODE:w,POSTGRES_USER:$,POSTGRES_PASSWORD:E,POSTGRES_DB:R,POSTGRES_HOST:N,POSTGRES_PORT:T,RPC_PROTOCOL:I,RPC_USER:O,RPC_PASSWORD:v,RPC_HOST:b,RPC_PORT:H,SERVER_VERSION:_,DEFAULT_WALLET:A,SYNC_INTERVAL_CHECK:x,POSTGRES_MAX_PARAM_NUM:M,DB_CONNECTION_RETRY_TIME:C,SIGNATURE_FRESHNESS_MINUTES:k,ALLOWED_RPC_METHODS:B,NODE_MAX_PROGRESS:P,SYNC_MAX_PROGRESS:F,MAX_BLOCKCHAIN_HEIGHT:L,MWEB_HEIGHT:D,BC_START_HEIGHT:W,WORKER_ID:K,NUM_WORKERS:G,SYNC_NON_STANDARD:U,ZMQ_WAIT_PERCENTAGE:Y}=process.env;const V=g||"LTC";const j=S||"regtest";const q=h||"dev";const z=f||"http://127.0.0.1:3000";const X=parseInt(w,10)||1;const Z=$||"bcn";const J=E||"bcn";const Q=R||"bcn";const tt=N||"127.0.0.1";const et=parseInt(T,10)||"5432";const st=I||"http";const nt=O||"bcn-admin";const at=v||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const rt=b||"node";const ot=parseInt(H,10)||19332;_||y.version;const it=parseInt(M,10)||1e4;const ct=parseInt(C,10)||500;!B||B.split(",").map((t=>new RegExp(t)));const lt=parseInt(W||"",10)||25e5;const dt=parseInt(K,10)||1;const pt=parseInt(G||"",10)||1;const yt="true"===U||!1;const ut=a.combine(a.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),a.printf((t=>`[${t.timestamp}] [${t.level}] ${t.message}`)));const mt=r({level:["error","warn","info","http","verbose","debug","silly"][X],format:ut,transports:[new o.Console({format:ut})],exceptionHandlers:[new o.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new o.File({filename:"logs/rejections.log"})]});const gt={maxFiles:1,maxSize:1e5};X>=0&&mt.add(new o.File({filename:"error.log",level:"error"})),X>=1&&mt.add(new o.File({filename:"logs/warn.log",level:"warn",...gt})),X>=2&&mt.add(new o.File({filename:"logs/info.log",level:"info",...gt})),X>=3&&mt.add(new o.File({filename:"logs/http.log",level:"http",...gt})),X>=4&&mt.add(new o.File({filename:"logs/verbose.log",level:"verbose",...gt})),X>=5&&mt.add(new o.File({filename:"logs/debug.log",level:"debug",...gt}));const St=new i({protocol:st,user:nt,pass:at,host:rt,port:ot});const ht=c.promisify(i.prototype.createwallet.bind(St));const ft=c.promisify(i.prototype.generateToAddress.bind(St));const wt=c.promisify(i.prototype.getaddressinfo.bind(St));const $t=c.promisify(i.prototype.getBlock.bind(St));const Et=c.promisify(i.prototype.getBlockchainInfo.bind(St));const Rt=c.promisify(i.prototype.getBlockHash.bind(St));const Nt=c.promisify(i.prototype.getRawTransaction.bind(St));const Tt=c.promisify(i.prototype.getTransaction.bind(St));const It=c.promisify(i.prototype.getNewAddress.bind(St));const Ot={createwallet:ht,generateToAddress:ft,getaddressinfo:wt,getBlock:$t,getBlockchainInfo:Et,getBlockHash:Rt,getRawTransaction:Nt,getTransaction:Tt,importaddress:c.promisify(i.prototype.importaddress.bind(St)),listunspent:c.promisify(i.prototype.listunspent.bind(St)),sendRawTransaction:c.promisify(i.prototype.sendRawTransaction.bind(St)),getNewAddress:It,sendToAddress:c.promisify(i.prototype.sendToAddress.bind(St))};const vt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:a,user:r,password:o}=e.cn;mt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${a}, user:${r}, password: ${o}`)}},noWarnings:!0};"dev"===q&&X>0&&(d.isAttached()?d.detach():(d.attach(vt),d.setTheme("matrix")));const bt=l(vt)({host:tt,port:et,database:Q,user:Z,password:J,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Ht}=l;class _t{static async select(t){const e=new Ht({name:`SyncStatus.select.${Math.random()}`,text:'SELECT "syncedHeight" FROM "SyncStatus" WHERE "workerId" = $1',values:[t]});return bt.one(e)}static async update({syncedHeight:t,workerId:e}){const s=new Ht({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "syncedHeight" = $1 WHERE "workerId" = $2',values:[t,e]});await bt.any(s)}static async insert({syncedHeight:t,workerId:e}){const s=new Ht({name:`SyncStatus.insert.${Math.random()}`,text:'INSERT INTO  "SyncStatus"("syncedHeight","workerId") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});await bt.any(s)}}class At{static async select(t){return _t.select(t)}static async update(t){await _t.update(t)}static async insert(t){await _t.insert(t)}}class xt{static updateSync=async t=>At.update(t);static selectSync=async t=>At.select(t);static insertSync=async t=>At.insert(t)}function Mt(t){return/^[0-9A-Fa-f]{64}\/\d+$/.test(t)}const{PreparedStatement:Ct}=l;class kt{static async query(t){const{publicKey:e,classHash:s,limit:n,offset:a,order:r,ids:o}=t;if(!e&&!s&&!o.length)return[];if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order");let i='SELECT "rev"\n      FROM "NonStandard"\n      WHERE true ';const c=[];e&&(c.push(e),i+=` AND $${c.length} = ANY ("publicKeys")`),s&&(c.push(s),i+=` AND "classHash" = $${c.length}`),o&&o.length&&(o.map(Mt),c.push(o),i+=` AND "id" = ANY ($${c.length})`),r&&(i+=` order by "lastUpdated" ${r}`),n&&(c.push(n),i+=` limit $${c.length}`),a&&(c.push(a),i+=` offset $${c.length}`);const l=new Ct({name:`NonStandard.query.${Math.random()}`,text:i,values:c});return(await bt.any(l)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,classHash:n}){const a=new Ct({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash") VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING',values:[t,e,s,n]});await bt.none(a)}static async update({id:t,rev:e,publicKeys:s}){const n=new Ct({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return bt.none(n)}static async getRevsByIds(t){const e=new Ct({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return bt.any(e)}static async select(t){const e=new Ct({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return bt.oneOrNone(e)}}class Bt{static async select(t){return kt.select(t)}static async query(t){return kt.query(t)}static async getRevsByIds(t){return kt.getRevsByIds(t)}static async insert(t){return kt.insert(t)}static async update(t){return kt.update(t)}}const{crypto:Pt}=p;class Ft{static add=async t=>{const{zip:e,outData:s}=t;await Promise.all(e.map((async([t,e],n)=>{const{exp:a="",_owners:r=[]}=s[n]||{};if(null===t&&e)return Mt(e),void await Bt.insert({id:e,rev:e,publicKeys:r,classHash:Pt.Hash.sha256(Buffer.from(a)).toString("hex")});if(e&&t){const{id:s,classHash:n}=await Bt.select(t)||{};await Bt.update({id:s,rev:e,publicKeys:r,classHash:n})}})))};static query=async t=>Bt.query(t);static getRevsByIds=async t=>(await Bt.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:Lt}=l;class Dt{static async select(t){const e=new Lt({name:`Input.select.${Math.random()}`,text:'SELECT "rev" FROM "Input" WHERE "rev" = $1',values:[t]});return bt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev]));for(;e.length;){const t=e.splice(0,it);const s=[];for(let e=1;e<=t.length;e+=1)s.push(`($${e})`);const n=s.join(",");const a=new Lt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("rev") VALUES ${n} ON CONFLICT DO NOTHING`,values:t});await bt.none(a)}}static async count(t){const e=t.map((t=>t.rev));const s=new Lt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "rev" LIKE ANY ($1)',values:[[e]]});const n=await bt.oneOrNone(s);return parseInt(n?.count,10)||0}}class Wt{static async select(t){return Dt.select(t)}static async insert(t){return Dt.insert(t)}}const{Transaction:Kt}=p;const{Input:Gt}=Kt;class Ut{static getNonCoinbaseRevs=t=>t.map((t=>Gt.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull())).map((({prevTxId:t,outputIndex:e})=>({rev:`${t.toString("hex")}/${e}`})));static insert=async t=>Wt.insert(this.getNonCoinbaseRevs(t))}const{PreparedStatement:Yt}=l;class Vt{static async select(t){const e=new Yt({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return bt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey]));for(;e.length;){const t=e.splice(0,it);const s=[];for(let e=1;e<=t.length;e+=4)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const n=s.join(",");const a=new Yt({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await bt.none(a)}}}class jt{static async select(t){return Vt.select(t)}static async insert(t){return Vt.insert(t)}}class qt{static insert=async t=>{const e=t.flatMap((t=>t.tx.outputs.map(((e,s)=>{const{script:n}=e;let a="false";!1===n.isMultisigOut()&&(a=n.toAddress(j).toString("legacy")),"false"===a&&(a=null);const r=n.toHex();const o=Math.round(e.satoshis);return{address:a,rev:`${t.txId}/${s}`,scriptPubKey:r,satoshis:o}}))));return jt.insert(e)}}const zt=new e({chain:V,network:j,url:z});class Xt{static waitForBlock=async e=>{await t((async()=>{mt.info(`Sync workerId ${dt}: waiting for block ${e} ...`),await Ot.getBlockHash(e)}),{startingDelay:3e4,timeMultiple:1,numOfAttempts:720}),mt.info(`Node is ready. Starting Sync actions for worker ${dt}`)};static syncBlock=async t=>{const{result:e}=await Ot.getBlockHash(t);const{result:s}=await Ot.getBlock(e,2);const{tx:n}=s;mt.info(`Backfilling progress ${t} Backfilling ${n.length} transactions...`);const a=await Promise.allSettled(n.map((t=>zt.txFromHex({hex:t.hex}))));const r=a.filter((t=>"fulfilled"===t.status)).map((t=>t.value));const o=a.filter((t=>"rejected"===t.status)).map((t=>t.reason));var i,c;o.length&&mt.error(`Failed to parse ${o.length} transactions of block num ${t}: ${o.map((t=>t)).join(", ")}\n        Failed txs: ${i=n.map((t=>t.id)),c=r.map((t=>t.tx.id)),i.filter((t=>-1===c.indexOf(t)))}`),await this.syncTxs(r,t)};static sync=async(t,e,s,n)=>{try{let a=e;const r=await xt.selectSync(t);for(r.syncedHeight>e&&(a=r.syncedHeight+s),mt.info(`Starting sync process { initialBlock: ${e} increment: ${s} nonStandard: ${n} syncedHeight:${r.syncedHeight}, currentBlockHeight:${a} }`);n||a<lt;)try{await this.syncBlock(a),await xt.updateSync({syncedHeight:a,workerId:t}),a+=s}catch(t){t.message.includes("out of range")||mt.error(`Syncing block num ${a} failed with error '${t.message}'`)}}catch(t){mt.error(`Sync action failed with error '${t.message}'`)}};static syncTxs=async(t,e)=>{try{await qt.insert(t),await Ut.insert(t.flatMap((t=>t.tx.inputs))),e>=lt&&t.map((async t=>{try{t.isBcTx(V,j)&&await Ft.add(t)}catch(e){mt.error(`Failed to add non-standard tx ${t.tx.txid} ${e.message}`)}}))}catch(t){mt.error(`Processing block ${e} failed with error '${t.message}'`)}};static register=async t=>{try{await xt.insertSync({syncedHeight:-1,workerId:t}),mt.info(`Register workerId: '${t}'`)}catch(t){mt.error(`Register action failed with error '${t.message}'`)}}}!function(){try{const e=`Synchronizing { nonStandard:${yt} url: ${z}, chain:${V} network:${j} numWorkers: ${pt} workerId: ${dt} }`;mt.info(e),"regtest"!==j&&(async()=>{await(async()=>{await t((()=>bt.connect()),{startingDelay:ct})})(),await Xt.register(dt),yt?(await Xt.waitForBlock(lt),await Xt.sync(dt,lt,1,yt)):(await Xt.waitForBlock(dt),await Xt.sync(dt,dt,pt,!1))})()}catch(t){mt.error(`Synchronizing failed with error '${t.message}'`)}}();

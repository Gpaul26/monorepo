import{backOff as t}from"exponential-backoff";import{Computer as e}from"@bitcoin-computer/lib";import s from"dotenv";import n from"fs";import a from"winston";import r from"winston-daily-rotate-file";import o from"bitcoind-rpc";import c from"util";import i from"pg-promise";import l from"pg-monitor";import d from"@bitcoin-computer/bitcore-lib-ltc";s.config();const p=JSON.parse(n.readFileSync("package.json","utf8"));const{PORT:m,ZMQ_URL:y,CHAIN:u,NETWORK:h,BCN_ENV:f,BCN_URL:g,DEBUG_MODE:w,POSTGRES_USER:$,POSTGRES_PASSWORD:S,POSTGRES_DB:E,POSTGRES_HOST:T,POSTGRES_PORT:R,RPC_PROTOCOL:I,RPC_USER:N,RPC_PASSWORD:O,RPC_HOST:v,RPC_PORT:H,SERVER_VERSION:M,DEFAULT_WALLET:b,SYNC_INTERVAL_CHECK:A,POSTGRES_MAX_PARAM_NUM:_,DB_CONNECTION_RETRY_TIME:D,SIGNATURE_FRESHNESS_MINUTES:C,ALLOWED_RPC_METHODS:x,NODE_MAX_PROGRESS:k,SYNC_MAX_PROGRESS:P,MAX_BLOCKCHAIN_HEIGHT:Y,MWEB_HEIGHT:L,BC_START_HEIGHT:B,WORKER_ID:F,NUM_WORKERS:W,SYNC_NON_STANDARD:G,ZMQ_WAIT_PERCENTAGE:K,QUERY_LIMIT:U,LOG_MAX_FILE_SIZE:j,LOG_MAX_FILE_NUM:V,LOG_ZIP:z}=process.env;const q=u||"LTC";const X=h||"regtest";const Z=f||"dev";const Q=g||"http://127.0.0.1:3000";const J=parseInt(w,10)||1;const tt=$||"bcn";const et=S||"bcn";const st=E||"bcn";const nt=T||"127.0.0.1";const at=parseInt(R,10)||"5432";const rt=I||"http";const ot=N||"bcn-admin";const ct=O||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const it=v||"node";const lt=parseInt(H,10)||19332;p.version;const dt=parseInt(_,10)||1e4;const pt=parseInt(D,10)||500;!x||x.split(",").map((t=>new RegExp(t)));const mt=parseInt(B||"",10)||25e5;const yt=parseInt(F,10)||1;const ut=parseInt(W||"",10)||1;const ht="true"===G||!1;const ft=parseInt(U||"",10)||100;const gt=j||"20m";const wt=V||"14d";const $t=!!z;a.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const St=a.format.combine(a.format.colorize(),a.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),a.format.json(),a.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const Et={zippedArchive:$t,maxSize:gt,maxFiles:wt,dirname:"logs"};const Tt=[];"dev"===Z&&Tt.push(new a.transports.Console({format:a.format.combine(a.format.colorize(),a.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),a.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))})),J>=0&&Tt.push(new r({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...Et})),J>=1&&Tt.push(new r({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...Et})),J>=2&&Tt.push(new r({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...Et})),J>=3&&Tt.push(new r({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...Et})),J>=4&&Tt.push(new r({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...Et})),Tt.push(new r({filename:"logs-%DATE%.log",datePattern:"YYYY-MM-DD"}));const Rt=a.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:St,transports:Tt,exceptionHandlers:[new a.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new a.transports.File({filename:"logs/rejections.log"})]});const It=new o({protocol:rt,user:ot,pass:ct,host:it,port:lt});const Nt=c.promisify(o.prototype.createwallet.bind(It));const Ot=c.promisify(o.prototype.generateToAddress.bind(It));const vt=c.promisify(o.prototype.getaddressinfo.bind(It));const Ht=c.promisify(o.prototype.getBlock.bind(It));const Mt=c.promisify(o.prototype.getBlockchainInfo.bind(It));const bt=c.promisify(o.prototype.getBlockHash.bind(It));const At=c.promisify(o.prototype.getRawTransaction.bind(It));const _t=c.promisify(o.prototype.getTransaction.bind(It));const Dt=c.promisify(o.prototype.getNewAddress.bind(It));const Ct={createwallet:Nt,generateToAddress:Ot,getaddressinfo:vt,getBlock:Ht,getBlockchainInfo:Mt,getBlockHash:bt,getRawTransaction:At,getTransaction:_t,importaddress:c.promisify(o.prototype.importaddress.bind(It)),listunspent:c.promisify(o.prototype.listunspent.bind(It)),sendRawTransaction:c.promisify(o.prototype.sendRawTransaction.bind(It)),getNewAddress:Dt,sendToAddress:c.promisify(o.prototype.sendToAddress.bind(It))};const xt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:a,user:r,password:o}=e.cn;Rt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${a}, user:${r}, password: ${o}`)}},noWarnings:!0};"dev"===Z&&J>0&&(l.isAttached()?l.detach():(l.attach(xt),l.setTheme("matrix")));const kt=i(xt)({host:nt,port:at,database:st,user:tt,password:et,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Pt}=i;class Yt{static async select(t){const e=new Pt({name:`SyncStatus.select.${Math.random()}`,text:'SELECT "syncedHeight" FROM "SyncStatus" WHERE "workerId" = $1',values:[t]});return kt.one(e)}static async update({syncedHeight:t,workerId:e}){const s=new Pt({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "syncedHeight" = $1 WHERE "workerId" = $2',values:[t,e]});await kt.any(s)}static async insert({syncedHeight:t,workerId:e}){const s=new Pt({name:`SyncStatus.insert.${Math.random()}`,text:'INSERT INTO  "SyncStatus"("syncedHeight","workerId") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});await kt.any(s)}}class Lt{static async select(t){return Yt.select(t)}static async update(t){await Yt.update(t)}static async insert(t){await Yt.insert(t)}}class Bt{static updateSync=async t=>Lt.update(t);static selectSync=async t=>Lt.select(t);static insertSync=async t=>Lt.insert(t)}function Ft(t){return/^[0-9A-Fa-f]{64}\/\d+$/.test(t)}const{PreparedStatement:Wt}=i;class Gt{static async query(t){const{publicKey:e,classHash:s,limit:n,offset:a,order:r,ids:o,mod:c}=t;if(n&&parseInt(n||"",10)>ft||o&&o.length>ft)throw new Error(`Can't fetch more than ${ft} revs.`);if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order");let i='SELECT "rev"\n      FROM "NonStandard"\n      WHERE true ';const l=[];e&&(l.push(e),i+=` AND $${l.length} = ANY ("publicKeys")`),s&&(l.push(s),i+=` AND "classHash" = $${l.length}`),c&&(l.push(c),i+=` AND "mod" = $${l.length}`),o&&o.length&&(o.map(Ft),l.push(o),i+=` AND "id" = ANY ($${l.length})`),r&&(i+=` order by "lastUpdated" ${r}`),l.push(n||ft),i+=` limit $${l.length}`,a&&(l.push(a),i+=` offset $${l.length}`);const d=new Wt({name:`NonStandard.query.${Math.random()}`,text:i,values:l});return(await kt.any(d)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,classHash:n,mod:a}){const r=new Wt({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash", "mod") VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING',values:[t,e,s,n,a]});await kt.none(r)}static async update({id:t,rev:e,publicKeys:s}){const n=new Wt({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return kt.none(n)}static async getRevsByIds(t){if(t&&t.length>ft)throw new Error(`Can't fetch more than ${ft} revs.`);const e=new Wt({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return kt.any(e)}static async select(t){const e=new Wt({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash", "mod" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return kt.oneOrNone(e)}}class Kt{static async select(t){return Gt.select(t)}static async query(t){return Gt.query(t)}static async getRevsByIds(t){return Gt.getRevsByIds(t)}static async insert(t){return Gt.insert(t)}static async update(t){return Gt.update(t)}}const{crypto:Ut}=d;class jt{static add=async t=>{const{zip:e,outData:s}=t;await Promise.all(e.map((async([t,e],n)=>{const{exp:a="",_owners:r=[],mod:o=""}=s[n]||{};if(!t&&e)return Ft(e),void await Kt.insert({id:e,rev:e,publicKeys:r,classHash:Ut.Hash.sha256(Buffer.from(a)).toString("hex"),mod:o});if(t&&e){const{id:s,classHash:n,mod:a}=await Kt.select(t)||{};await Kt.update({id:s,rev:e,publicKeys:r,classHash:n,mod:a})}})))};static query=async t=>Kt.query(t);static getRevsByIds=async t=>(await Kt.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:Vt}=i;class zt{static async select(t){const e=new Vt({name:`Input.select.${Math.random()}`,text:'SELECT "rev" FROM "Input" WHERE "rev" = $1',values:[t]});return kt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev]));for(;e.length;){const t=e.splice(0,dt);const s=[];for(let e=1;e<=t.length;e+=1)s.push(`($${e})`);const n=s.join(",");const a=new Vt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("rev") VALUES ${n} ON CONFLICT DO NOTHING`,values:t});await kt.none(a)}}static async count(t){const e=t.map((t=>t.rev));const s=new Vt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "rev" LIKE ANY ($1)',values:[[e]]});const n=await kt.oneOrNone(s);return parseInt(n?.count,10)||0}}class qt{static async select(t){return zt.select(t)}static async insert(t){return zt.insert(t)}}const{Transaction:Xt}=d;const{Input:Zt}=Xt;class Qt{static getNonCoinbaseRevs=t=>t.map((t=>Zt.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull())).map((({prevTxId:t,outputIndex:e})=>({rev:`${t.toString("hex")}/${e}`})));static insert=async t=>qt.insert(this.getNonCoinbaseRevs(t))}const{PreparedStatement:Jt}=i;class te{static async select(t){const e=new Jt({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return kt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey]));for(;e.length;){const t=e.splice(0,dt);const s=[];for(let e=1;e<=t.length;e+=4)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const n=s.join(",");const a=new Jt({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await kt.none(a)}}}class ee{static async select(t){return te.select(t)}static async insert(t){return te.insert(t)}}class se{static insert=async t=>{const e=t.flatMap((t=>t.tx.outputs.map(((e,s)=>{const{script:n}=e;let a="false";!1===n.isMultisigOut()&&(a=n.toAddress(X).toString("legacy")),"false"===a&&(a=null);const r=n.toHex();const o=Math.round(e.satoshis);return{address:a,rev:`${t.txId}/${s}`,scriptPubKey:r,satoshis:o}}))));return ee.insert(e)}}const ne=new e({chain:q,network:X,url:Q});class ae{static waitForBlock=async e=>{await t((async()=>{Rt.info(`Sync workerId ${yt}: waiting for block ${e} ...`),await Ct.getBlockHash(e)}),{startingDelay:3e4,timeMultiple:1,numOfAttempts:720}),Rt.info(`Node is ready. Starting Sync actions for worker ${yt}`)};static syncBlock=async t=>{const{result:e}=await Ct.getBlockHash(t);const{result:s}=await Ct.getBlock(e,2);const{tx:n}=s;Rt.info(`Backfilling progress ${t} Backfilling ${n.length} transactions...`);const a=await Promise.allSettled(n.map((t=>ne.txFromHex({hex:t.hex}))));const r=a.filter((t=>"fulfilled"===t.status)).map((t=>t.value));const o=a.filter((t=>"rejected"===t.status)).map((t=>t.reason));var c,i;o.length&&Rt.error(`Failed to parse ${o.length} transactions of block num ${t}: ${o.map((t=>t)).join(", ")}\n        Failed txs: ${c=n.map((t=>t.id)),i=r.map((t=>t.tx.id)),c.filter((t=>-1===i.indexOf(t)))}`),await this.syncTxs(r,t)};static sync=async(t,e,s,n)=>{try{let a=e;const r=await Bt.selectSync(t);for(r.syncedHeight>e&&(a=r.syncedHeight+s),Rt.info(`Starting sync process { initialBlock: ${e} increment: ${s} nonStandard: ${n} syncedHeight:${r.syncedHeight}, currentBlockHeight:${a} }`);n||a<mt;)try{await this.syncBlock(a),await Bt.updateSync({syncedHeight:a,workerId:t}),a+=s}catch(t){t.message.includes("out of range")||Rt.error(`Syncing block num ${a} failed with error '${t.message}'`)}}catch(t){Rt.error(`Sync action failed with error '${t.message}'`)}};static syncTxs=async(t,e)=>{try{await se.insert(t),await Qt.insert(t.flatMap((t=>t.tx.inputs))),e>=mt&&t.map((async t=>{try{t.isBcTx(q,X)&&await jt.add(t)}catch(e){Rt.error(`Failed to add non-standard tx ${t.tx.txid} ${e.message}`)}}))}catch(t){Rt.error(`Processing block ${e} failed with error '${t.message}'`)}};static register=async t=>{try{await Bt.insertSync({syncedHeight:-1,workerId:t}),Rt.info(`Register workerId: '${t}'`)}catch(t){Rt.error(`Register action failed with error '${t.message}'`)}}}!function(){try{const e=`Synchronizing { nonStandard:${ht} url: ${Q}, chain:${q} network:${X} numWorkers: ${ut} workerId: ${yt} }`;Rt.info(e),"regtest"!==X&&(async()=>{if(await(async()=>{await t((()=>kt.connect()),{startingDelay:pt})})(),await ae.register(yt),ht)await ae.waitForBlock(mt),await ae.sync(yt,mt,1,ht);else{const t=await Bt.selectSync(yt);const e=t.syncedHeight>0?t.syncedHeight+1:yt;Rt.info(`Worker ${yt} waiting for block ${e}...`),await ae.waitForBlock(e),Rt.info(`Worker ${yt} starting sync on block ${e}...`),await ae.sync(yt,e,ut,!1)}})()}catch(t){Rt.error(`Synchronizing failed with error '${t.message}'`)}}();

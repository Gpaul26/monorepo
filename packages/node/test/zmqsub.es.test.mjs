import t from"bitcoind-rpc";import e from"chai";import s from"sinon";import n from"sinon-chai";import{Computer as r}from"@bitcoin-computer/lib";import a from"fs";import{createLogger as o,format as i,transports as c}from"winston";import d from"dotenv";import l from"is-primitive";import f from"is-plain-object";import u from"os";import{dirname as p}from"path";import{fileURLToPath as y}from"url";import b from"util";import m from"@bitcoin-computer/bitcore-lib-ltc";import h from"pg-promise";import g from"pg-monitor";import"exponential-backoff";const{deleteProperty:w}=Reflect;const v=l;const S=f;const T=t=>"object"==typeof t&&null!==t||"function"==typeof t;const E=t=>{if(!v(t))throw new TypeError("Object keys must be strings or symbols");if((t=>"__proto__"===t||"constructor"===t||"prototype"===t)(t))throw new Error(`Cannot set unsafe key: "${t}"`)};const $=(t,e)=>e&&"function"==typeof e.split?e.split(t):"symbol"==typeof t?[t]:Array.isArray(t)?t:((t,e,s)=>{const n=(t=>Array.isArray(t)?t.flat().map(String).join(","):t)(e?((t,e)=>{if("string"!=typeof t||!e)return t;let s=t+";";return void 0!==e.arrays&&(s+=`arrays=${e.arrays};`),void 0!==e.separator&&(s+=`separator=${e.separator};`),void 0!==e.split&&(s+=`split=${e.split};`),void 0!==e.merge&&(s+=`merge=${e.merge};`),void 0!==e.preservePaths&&(s+=`preservePaths=${e.preservePaths};`),s})(t,e):t);E(n);const r=N.cache.get(n)||s();return N.cache.set(n,r),r})(t,e,(()=>((t,e={})=>{const s=e.separator||".";const n="/"!==s&&e.preservePaths;if("string"==typeof t&&!1!==n&&/\//.test(t))return[t];const r=[];let a="";const o=t=>{let e;""!==t.trim()&&Number.isInteger(e=Number(t))?r.push(e):r.push(t)};for(let e=0;e<t.length;e++){const n=t[e];"\\"!==n?n!==s?a+=n:(o(a),a=""):a+=t[++e]}return a&&o(a),r})(t,e)));const R=(t,e,s,n)=>{if(E(e),void 0===s)w(t,e);else if(n&&n.merge){const r="function"===n.merge?n.merge:Object.assign;r&&S(t[e])&&S(s)?t[e]=r(t[e],s):t[e]=s}else t[e]=s;return t};const N=(t,e,s,n)=>{if(!e||!T(t))return t;const r=$(e,n);let a=t;for(let t=0;t<r.length;t++){const e=r[t];const o=r[t+1];if(E(e),void 0===o){R(a,e,s,n);break}"number"!=typeof o||Array.isArray(a[e])?(T(a[e])||(a[e]={}),a=a[e]):a=a[e]=[]}return t};N.split=$,N.cache=new Map,N.clear=()=>{N.cache=new Map};var O=N;var x=a;var _="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var I="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var A=function(){function t(t,e){for(var s=0;s<e.length;s++){var n=e[s];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,s,n){return s&&t(e.prototype,s),n&&t(e,n),e}}();var H=function t(e,s){var n=s.indexOf(".");if(!~n){if(null==e)return;return e[s]}var r=s.substring(0,n),a=s.substring(n+1);if(null!=e)return e=e[r],a?t(e,a):e},P=O,k=function(t,e){if("function"!=typeof e)return JSON.parse(x.readFileSync(t));x.readFile(t,"utf-8",(function(t,s){try{s=JSON.parse(s)}catch(e){t=t||e}e(t,s)}))},M=a,C=u;var F=function(){function t(e,s){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.options=s=s||{},s.stringify_width=s.stringify_width||2,s.stringify_fn=s.stringify_fn||null,s.stringify_eol=s.stringify_eol||!1,s.ignore_dots=s.ignore_dots||!1,this.path=e,this.data=this.read()}return A(t,[{key:"set",value:function(t,e,s){var n=this;return"object"===(void 0===t?"undefined":I(t))?function(t,e){var s=0,n=[];if(Array.isArray(t))for(;s<t.length&&!1!==e(t[s],s);++s);else if("object"===(void 0===t?"undefined":_(t))&&null!==t)for(n=Object.keys(t);s<n.length&&!1!==e(t[n[s]],n[s]);++s);}(t,(function(t,e){P(n.data,e,t,s)})):this.options.ignore_dots?this.data[t]=e:P(this.data,t,e,s),this.options.autosave&&this.save(),this}},{key:"get",value:function(t){return t?this.options.ignore_dots?this.data[t]:H(this.data,t):this.toObject()}},{key:"unset",value:function(t){return this.set(t,void 0)}},{key:"append",value:function(t,e){var s=this.get(t);if(s=void 0===s?[]:s,!Array.isArray(s))throw new Error("The data is not an array!");return s.push(e),this.set(t,s),this}},{key:"pop",value:function(t){var e=this.get(t);if(!Array.isArray(e))throw new Error("The data is not an array!");return e.pop(),this.set(t,e),this}},{key:"read",value:function(t){if(!t)try{return k(this.path)}catch(t){return{}}k(this.path,(function(e,s){t(null,s=e?{}:s)}))}},{key:"write",value:function(t,e){return e?M.writeFile(this.path,t,e):M.writeFileSync(this.path,t),this}},{key:"empty",value:function(t){return this.write("{}",t)}},{key:"save",value:function(t){var e=JSON.stringify(this.data,this.options.stringify_fn,this.options.stringify_width,this.options.stringify_eol);return this.write(this.options.stringify_eol?e+C.EOL:e,t),this}},{key:"toObject",value:function(){return this.data}}]),t}();d.config();const L=new F(`${p(y(import.meta.url))}/../../package.json`,{stringify_eol:!0});const{PORT:B,ZMQ_URL:W,CHAIN:j,NETWORK:D,BCN_ENV:K,BCN_URL:U,DEBUG_MODE:G,POSTGRES_USER:Y,POSTGRES_PASSWORD:q,POSTGRES_DB:z,POSTGRES_HOST:V,POSTGRES_PORT:J,RPC_PROTOCOL:Z,RPC_USER:Q,RPC_PASSWORD:X,RPC_HOST:tt,RPC_PORT:et,SERVER_VERSION:st,DEFAULT_WALLET:nt,SYNC_HEIGHT:rt,SYNC_INTERVAL_CHECK:at,POSTGRES_MAX_PARAM_NUM:ot,DB_CONNECTION_RETRY_TIME:ct,SIGNATURE_FRESHNESS_MINUTES:dt,ALLOWED_RPC_METHODS:lt,MWEB_HEIGHT:ft}=process.env;const ut=j||"LTC";const pt=D||"regtest";const yt=K||"dev";const bt=U||"http://127.0.0.1:3000";const mt=parseInt(G,10)||1;const ht=Y||"bcn";const gt=q||"bcn";const wt=z||"bcn";const vt=V||"127.0.0.1";const St=parseInt(J,10)||"5432";const Tt=Z||"http";const Et=Q||"bcn-admin";const $t=X||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const Rt=tt||"node";const Nt=parseInt(et,10)||19332;const Ot=st||L.get("version");const xt=nt||"defaultwallet";const _t=parseInt(at,10)||3e3;const It=parseInt(ot,10)||1e4;!lt||lt.split(",").map((t=>new RegExp(t)));const At=parseInt(ft||"",10)||432;const Ht=o({level:["error","warn","info","http","verbose","debug","silly"][mt],format:i.json(),transports:[new c.Console({format:i.combine(i.colorize(),i.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),i.printf((t=>`[2m${t.timestamp}[0m ${t.level} ${t.message}`)))})],exceptionHandlers:[new c.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new c.File({filename:"logs/rejections.log"})]});const Pt={maxFiles:1,maxSize:1e5};mt>=0&&Ht.add(new c.File({filename:"error.log",level:"error"})),mt>=1&&Ht.add(new c.File({filename:"logs/warn.log",level:"warn",...Pt})),mt>=2&&Ht.add(new c.File({filename:"logs/info.log",level:"info",...Pt})),mt>=3&&Ht.add(new c.File({filename:"logs/http.log",level:"http",...Pt})),mt>=4&&Ht.add(new c.File({filename:"logs/verbose.log",level:"verbose",...Pt})),mt>=5&&Ht.add(new c.File({filename:"logs/debug.log",level:"debug",...Pt}));const kt=t=>new Promise((e=>{setTimeout(e,t)}));const Mt=(t,e)=>Object.assign(new Array(e).fill(null),t);const Ct=new t({protocol:Tt,user:Et,pass:$t,host:Rt,port:Nt});const Ft=b.promisify(t.prototype.createwallet.bind(Ct));const Lt=b.promisify(t.prototype.generateToAddress.bind(Ct));const Bt=b.promisify(t.prototype.getaddressinfo.bind(Ct));const Wt=b.promisify(t.prototype.getBlock.bind(Ct));const jt=b.promisify(t.prototype.getBlockchainInfo.bind(Ct));const Dt=b.promisify(t.prototype.getBlockHash.bind(Ct));const Kt=b.promisify(t.prototype.getRawTransaction.bind(Ct));const Ut=b.promisify(t.prototype.getTransaction.bind(Ct));const Gt=b.promisify(t.prototype.getNewAddress.bind(Ct));const Yt={createwallet:Ft,generateToAddress:Lt,getaddressinfo:Bt,getBlock:Wt,getBlockchainInfo:jt,getBlockHash:Dt,getRawTransaction:Kt,getTransaction:Ut,importaddress:b.promisify(t.prototype.importaddress.bind(Ct)),listunspent:b.promisify(t.prototype.listunspent.bind(Ct)),sendRawTransaction:b.promisify(t.prototype.sendRawTransaction.bind(Ct)),getNewAddress:Gt,sendToAddress:b.promisify(t.prototype.sendToAddress.bind(Ct))};const qt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:r,user:a,password:o}=e.cn;Ht.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${r}, user:${a}, password: ${o}`)}},noWarnings:!0};"dev"===yt&&mt>0&&(g.isAttached()?g.detach():(g.attach(qt),g.setTheme("matrix")));const zt=h(qt)({host:vt,port:St,database:wt,user:ht,password:gt,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Vt}=h;class Jt{static async select(t){const e=new Vt({name:`Input.select.${Math.random()}`,text:'SELECT "rev" FROM "Input" WHERE "rev" = $1',values:[t]});return zt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev]));for(;e.length;){const t=e.splice(0,It);const s=[];for(let e=1;e<=t.length;e+=1)s.push(`($${e})`);const n=s.join(",");const r=new Vt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("rev") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await zt.none(r)}}static async count(t){const e=t.map((t=>t.rev));const s=new Vt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "rev" LIKE ANY ($1)',values:[[e]]});const n=await zt.oneOrNone(s);return parseInt(n?.count,10)||0}}const{Transaction:Zt}=m;const{Input:Qt}=Zt;class Xt{static getNonCoinbaseRevs=t=>t.map((t=>Qt.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull())).map((({prevTxId:t,outputIndex:e})=>({rev:`${t.toString("hex")}/${e}`})));static insert=async t=>class{static async select(t){return Jt.select(t)}static async insert(t){return Jt.insert(t)}}.insert(this.getNonCoinbaseRevs(t))}const{PreparedStatement:te}=h;class ee{static async select(t){const e=new te({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return zt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey]));for(;e.length;){const t=e.splice(0,It);const s=[];for(let e=1;e<=t.length;e+=4)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const n=s.join(",");const r=new te({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await zt.none(r)}}}const{Script:se}=m;class ne{static insert=async(t,e)=>{const s=t.map(((t,s)=>{const n=se.fromBuffer(t._scriptBuffer);let r=n.toAddress(pt).toString("legacy");"false"===r&&(r=null);const a=n.toHex();const o=Math.round(t.satoshis);return{address:r,rev:`${e}/${s}`,scriptPubKey:a,satoshis:o}}));return class{static async select(t){return ee.select(t)}static async insert(t){return ee.insert(t)}}.insert(s)}}const{PreparedStatement:re}=h;class ae{static async query(t){const{publicKey:e,classHash:s}=t;if(void 0===e&&void 0===s)return[];let n='SELECT "rev"\n      FROM "NonStandard"\n      WHERE true ';const r=[];e&&(r.push(e),n+=' AND $1 = ANY ("publicKeys")'),s&&(r.push(s),n+=` AND "classHash" = $${r.length}`);const a=new re({name:`NonStandard.query.${Math.random()}`,text:n,values:r});return(await zt.any(a)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,classHash:n}){const r=new re({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash") VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING',values:[t,e,s,n]});await zt.none(r)}static async update({id:t,rev:e,publicKeys:s}){const n=new re({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return zt.none(n)}static async getRevsByIds(t){const e=new re({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return zt.any(e)}static async select(t){const e=new re({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return zt.oneOrNone(e)}}class oe{static async select(t){return ae.select(t)}static async query(t){return ae.query(t)}static async getRevsByIds(t){return ae.getRevsByIds(t)}static async insert(t){return ae.insert(t)}static async update(t){return ae.update(t)}}const{crypto:ie}=m;class ce{static add=async(t,e,s)=>{const n=Math.max(t.length,e.length);const r=Mt(t,n);const a=Mt(e,n);const o=(i=a,r.map(((t,e)=>[t,i[e]])));var i;await Promise.all(o.map((async([t,e],n)=>{const{__cls:r="",_owners:a=[]}=s[n]||{};if(null===t&&e)return/^[0-9A-Fa-f]{64}\/\d+$/.test(e),void await oe.insert({id:e,rev:e,publicKeys:a,classHash:ie.Hash.sha256(Buffer.from(r)).toString("hex")});if(e&&t){const{id:s,classHash:n}=await oe.select(t)||{};await oe.update({id:s,rev:e,publicKeys:a,classHash:n})}})))};static query=async t=>oe.query(t);static getRevsByIds=async t=>(await oe.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:de}=h;class le{static async select(){return zt.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncStatus"')}static async update({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}){const n=new de({name:`Sync.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,s]});await zt.any(n)}}class fe{static async select(){return le.select()}static async update(t){await le.update(t)}}class ue{static updateSync=async t=>fe.update(t);static selectSync=async()=>fe.select()}const pe=new r({chain:ut,network:pt,url:bt});class ye{static syncTx=async t=>{await ne.insert(t.tx.outputs,t.txId),await Xt.insert(t.tx.inputs);const{inRevs:e=[],outRevs:s=[],outData:n=[]}=t;await ce.add(e,s,n)};static rawTxSubscriber=async t=>{try{const e=t.toString("hex");Ht.info(`ZMQ message { rawTx:${e} }`),"dev"===yt&&a.appendFileSync("zmqlog.log",`${e} \r\n`);const s=await pe.db.fromTxHex(e);try{await this.syncTx(s)}catch(t){Ht.error(`Error parsing transaction ${t.message} ${t.stack}`)}}catch(t){Ht.error(`RawTxSubscriber failed with error '${t.message} ${t.stack}'`)}};static checkSyncEnd=async()=>{let t=-1;let e=-1;let s=0;Ht.info("Checking sync progress...syncedHeight: -1 from -1");do{({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}=await ue.selectSync()),t>0?Ht.info(`Sync progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*s).toFixed(4)}%)]`):Ht.info(`Sync progress initializing... ${t}/${e} blocks `),await kt(_t)}while(t<e||s<.999);Ht.info(`BCN reaches sync end...currentBlockHeight: ${t} from ${e} (chain progress: ${(100*s).toFixed(4)})`)};static createWallet=async()=>{try{await Yt.createwallet(xt)}catch(t){Ht.debug(`Wallet creation failed with error '${t.message}'`)}};static sub=async t=>{try{await this.createWallet(),"regtest"!==pt&&await this.checkSyncEnd(),await(async()=>{if("LTC"===ut&&"regtest"===pt){Ht.info(`Node is starting for chain ${ut} and network ${pt}, Starting MWEB setup.`);const{result:t}=await Yt.getBlockchainInfo();const e=t.blocks;if(e<At){const{result:t}=await Yt.getNewAddress("","legacy");const s=At-e-1;s&&await Yt.generateToAddress(s,t);const{result:n}=await Yt.getNewAddress("mweb","mweb");await Yt.sendToAddress(n,1),await Yt.generateToAddress(1,t)}Ht.info("MWEB setup is complete")}})(),Ht.info(`Bitcoin Computer Node is ready ${Ot}`);for await(const[,e]of t)await this.rawTxSubscriber(e)}catch(t){Ht.error(`ZMQ subscription failed with error '${t.message}'`)}}}e.use(n);const{expect:be}=e;afterEach((()=>{s.restore()})),describe("zmqsub",(()=>{describe("rawTxSubscriber",(()=>{it("Should ignore a standard rawtx",(async()=>{const e="01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0104ffffffff0100f2052a0100000043410496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858eeac00000000";const n="0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098";const r={txid:n,hash:"906c7434c759c8baf9bea2429a849942143cbed7bae22d34086bbfbafff2c582",version:1,vin:[],vout:[{value:50,n:0,scriptPubKey:{hex:"410496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858eeac",addresses:["12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX"]},txId:n}],nLockTime:0};const a={};a[e]=r;const o=s.stub(ne,"insert").resolves();const i=s.stub(ce,"add");const c=s.stub(t.prototype,"decodeRawTransaction").callsFake(((t,e)=>{e(null,{result:a[t]})}));await ye.rawTxSubscriber(e),be(i.calledWith([],[],[])).to.be.true,i.restore(),c.restore(),o.restore()})),it("Should sync a coinbase testnet rawtx",(async()=>{const e="01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0b03c58c01062f503253482fffffffff0386600f27010000001976a914dde4906f870df11cf316b15adb628a3c3cc9883988ac8ab8f60200000000434104ffd03de44a6e11b9917f3a29f9443283d9871c9d743ef30d5eddcd37094b64d1b3d8090496b53256786bf5c82932ec23c3b74d9f05a6f95a8b5529352656664bac00000000000000002a6a28e73cd21eb4ac1eb1ba3767f4bf12be98935656451df3d6dee34c125662bcd599000000000000010000000000";const n=new r;const a=await n.db.fromTxHex(e);const o={};o[e]=a;const i=s.stub(ne,"insert").resolves();const c=s.stub(Xt,"insert").resolves();const d=s.stub(ce,"add").resolves();const l=s.stub(t.prototype,"decodeRawTransaction").callsFake(((t,e)=>{e(null,{result:o[t]})}));await ye.rawTxSubscriber(e),be(i.calledWith(a.tx.outputs,a.tx.id)).to.be.true,be(c.calledWith(a.tx.inputs)).to.be.true,be(d.calledWith([],[],[])).to.be.true,l.restore(),i.restore(),c.restore(),d.restore()})),it("Should sync another coinbase testnet rawtx",(async()=>{const e="01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0b03c58c01062f503253482fffffffff0386600f27010000001976a914dde4906f870df11cf316b15adb628a3c3cc9883988ac8ab8f60200000000434104ffd03de44a6e11b9917f3a29f9443283d9871c9d743ef30d5eddcd37094b64d1b3d8090496b53256786bf5c82932ec23c3b74d9f05a6f95a8b5529352656664bac00000000000000002a6a28e73cd21eb4ac1eb1ba3767f4bf12be98935656451df3d6dee34c125662bcd599000000000000010000000000";const n=new r;const a=await n.db.fromTxHex(e);const o={};o[e]=a;const i=s.stub(ne,"insert").resolves();const c=s.stub(Xt,"insert").resolves();const d=s.stub(ce,"add").resolves();const l=s.stub(t.prototype,"decodeRawTransaction").callsFake(((t,e)=>{e(null,{result:o[t]})}));await ye.rawTxSubscriber(e),be(i.calledWith(a.tx.outputs,a.tx.id)).to.be.true,be(c.calledWith(a.tx.inputs)).to.be.true,be(d.calledWith([],[],[])).to.be.true,l.restore(),i.restore(),c.restore(),d.restore()}))}))}));

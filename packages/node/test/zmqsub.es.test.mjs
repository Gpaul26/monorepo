import t from"bitcoind-rpc";import e from"chai";import s from"sinon";import n from"sinon-chai";import{Computer as a}from"@bitcoin-computer/lib";import r from"fs";import{createLogger as o,format as c,transports as i}from"winston";import d from"dotenv";import f from"is-primitive";import l from"is-plain-object";import u from"os";import{dirname as b}from"path";import{fileURLToPath as p}from"url";import y from"util";import h from"@bitcoin-computer/bitcore-lib-ltc";import m from"pg-promise";import g from"pg-monitor";import"exponential-backoff";const{deleteProperty:w}=Reflect;const v=f;const S=l;const T=t=>"object"==typeof t&&null!==t||"function"==typeof t;const E=t=>{if(!v(t))throw new TypeError("Object keys must be strings or symbols");if((t=>"__proto__"===t||"constructor"===t||"prototype"===t)(t))throw new Error(`Cannot set unsafe key: "${t}"`)};const $=(t,e)=>e&&"function"==typeof e.split?e.split(t):"symbol"==typeof t?[t]:Array.isArray(t)?t:((t,e,s)=>{const n=(t=>Array.isArray(t)?t.flat().map(String).join(","):t)(e?((t,e)=>{if("string"!=typeof t||!e)return t;let s=t+";";return void 0!==e.arrays&&(s+=`arrays=${e.arrays};`),void 0!==e.separator&&(s+=`separator=${e.separator};`),void 0!==e.split&&(s+=`split=${e.split};`),void 0!==e.merge&&(s+=`merge=${e.merge};`),void 0!==e.preservePaths&&(s+=`preservePaths=${e.preservePaths};`),s})(t,e):t);E(n);const a=R.cache.get(n)||s();return R.cache.set(n,a),a})(t,e,(()=>((t,e={})=>{const s=e.separator||".";const n="/"!==s&&e.preservePaths;if("string"==typeof t&&!1!==n&&/\//.test(t))return[t];const a=[];let r="";const o=t=>{let e;""!==t.trim()&&Number.isInteger(e=Number(t))?a.push(e):a.push(t)};for(let e=0;e<t.length;e++){const n=t[e];"\\"!==n?n!==s?r+=n:(o(r),r=""):r+=t[++e]}return r&&o(r),a})(t,e)));const x=(t,e,s,n)=>{if(E(e),void 0===s)w(t,e);else if(n&&n.merge){const a="function"===n.merge?n.merge:Object.assign;a&&S(t[e])&&S(s)?t[e]=a(t[e],s):t[e]=s}else t[e]=s;return t};const R=(t,e,s,n)=>{if(!e||!T(t))return t;const a=$(e,n);let r=t;for(let t=0;t<a.length;t++){const e=a[t];const o=a[t+1];if(E(e),void 0===o){x(r,e,s,n);break}"number"!=typeof o||Array.isArray(r[e])?(T(r[e])||(r[e]={}),r=r[e]):r=r[e]=[]}return t};R.split=$,R.cache=new Map,R.clear=()=>{R.cache=new Map};var N=R;var O=r;var _="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var I="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var H=function(){function t(t,e){for(var s=0;s<e.length;s++){var n=e[s];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,s,n){return s&&t(e.prototype,s),n&&t(e,n),e}}();var A=function t(e,s){var n=s.indexOf(".");if(!~n){if(null==e)return;return e[s]}var a=s.substring(0,n),r=s.substring(n+1);if(null!=e)return e=e[a],r?t(e,r):e},k=N,P=function(t,e){if("function"!=typeof e)return JSON.parse(O.readFileSync(t));O.readFile(t,"utf-8",(function(t,s){try{s=JSON.parse(s)}catch(e){t=t||e}e(t,s)}))},M=r,C=u;var F=function(){function t(e,s){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.options=s=s||{},s.stringify_width=s.stringify_width||2,s.stringify_fn=s.stringify_fn||null,s.stringify_eol=s.stringify_eol||!1,s.ignore_dots=s.ignore_dots||!1,this.path=e,this.data=this.read()}return H(t,[{key:"set",value:function(t,e,s){var n=this;return"object"===(void 0===t?"undefined":I(t))?function(t,e){var s=0,n=[];if(Array.isArray(t))for(;s<t.length&&!1!==e(t[s],s);++s);else if("object"===(void 0===t?"undefined":_(t))&&null!==t)for(n=Object.keys(t);s<n.length&&!1!==e(t[n[s]],n[s]);++s);}(t,(function(t,e){k(n.data,e,t,s)})):this.options.ignore_dots?this.data[t]=e:k(this.data,t,e,s),this.options.autosave&&this.save(),this}},{key:"get",value:function(t){return t?this.options.ignore_dots?this.data[t]:A(this.data,t):this.toObject()}},{key:"unset",value:function(t){return this.set(t,void 0)}},{key:"append",value:function(t,e){var s=this.get(t);if(s=void 0===s?[]:s,!Array.isArray(s))throw new Error("The data is not an array!");return s.push(e),this.set(t,s),this}},{key:"pop",value:function(t){var e=this.get(t);if(!Array.isArray(e))throw new Error("The data is not an array!");return e.pop(),this.set(t,e),this}},{key:"read",value:function(t){if(!t)try{return P(this.path)}catch(t){return{}}P(this.path,(function(e,s){t(null,s=e?{}:s)}))}},{key:"write",value:function(t,e){return e?M.writeFile(this.path,t,e):M.writeFileSync(this.path,t),this}},{key:"empty",value:function(t){return this.write("{}",t)}},{key:"save",value:function(t){var e=JSON.stringify(this.data,this.options.stringify_fn,this.options.stringify_width,this.options.stringify_eol);return this.write(this.options.stringify_eol?e+C.EOL:e,t),this}},{key:"toObject",value:function(){return this.data}}]),t}();d.config();const L=new F(`${b(p(import.meta.url))}/../../package.json`,{stringify_eol:!0});const{PORT:W,ZMQ_URL:B,CHAIN:j,NETWORK:D,BCN_ENV:K,BCN_URL:U,DEBUG_MODE:G,POSTGRES_USER:Y,POSTGRES_PASSWORD:q,POSTGRES_DB:z,POSTGRES_HOST:V,POSTGRES_PORT:J,RPC_PROTOCOL:Z,RPC_USER:Q,RPC_PASSWORD:X,RPC_HOST:tt,RPC_PORT:et,SERVER_VERSION:st,DEFAULT_WALLET:nt,SYNC_HEIGHT:at,SYNC_INTERVAL_CHECK:rt,POSTGRES_MAX_PARAM_NUM:ot,DB_CONNECTION_RETRY_TIME:ct,SIGNATURE_FRESHNESS_MINUTES:dt,ALLOWED_RPC_METHODS:ft,MWEB_HEIGHT:lt}=process.env;const ut=j||"LTC";const bt=D||"regtest";const pt=K||"dev";const yt=U||"http://127.0.0.1:3000";const ht=parseInt(G,10)||1;const mt=Y||"bcn";const gt=q||"bcn";const wt=z||"bcn";const vt=V||"127.0.0.1";const St=parseInt(J,10)||"5432";const Tt=Z||"http";const Et=Q||"bcn-admin";const $t=X||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const xt=tt||"node";const Rt=parseInt(et,10)||19332;const Nt=st||L.get("version");const Ot=nt||"defaultwallet";const _t=parseInt(rt,10)||3e3;const It=parseInt(ot,10)||1e4;!ft||ft.split(",").map((t=>new RegExp(t)));const Ht=parseInt(lt||"",10)||432;const At=o({level:["error","warn","info","http","verbose","debug","silly"][ht],format:c.json(),transports:[new i.Console({format:c.combine(c.colorize(),c.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),c.printf((t=>`[2m${t.timestamp}[0m ${t.level} ${t.message}`)))})],exceptionHandlers:[new i.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new i.File({filename:"logs/rejections.log"})]});const kt={maxFiles:1,maxSize:1e5};ht>=0&&At.add(new i.File({filename:"error.log",level:"error"})),ht>=1&&At.add(new i.File({filename:"logs/warn.log",level:"warn",...kt})),ht>=2&&At.add(new i.File({filename:"logs/info.log",level:"info",...kt})),ht>=3&&At.add(new i.File({filename:"logs/http.log",level:"http",...kt})),ht>=4&&At.add(new i.File({filename:"logs/verbose.log",level:"verbose",...kt})),ht>=5&&At.add(new i.File({filename:"logs/debug.log",level:"debug",...kt}));const Pt=t=>new Promise((e=>{setTimeout(e,t)}));const Mt=(t,e)=>Object.assign(new Array(e).fill(null),t);const Ct=new t({protocol:Tt,user:Et,pass:$t,host:xt,port:Rt});const Ft=y.promisify(t.prototype.createwallet.bind(Ct));const Lt=y.promisify(t.prototype.generateToAddress.bind(Ct));const Wt=y.promisify(t.prototype.getaddressinfo.bind(Ct));const Bt=y.promisify(t.prototype.getBlock.bind(Ct));const jt=y.promisify(t.prototype.getBlockchainInfo.bind(Ct));const Dt=y.promisify(t.prototype.getBlockHash.bind(Ct));const Kt=y.promisify(t.prototype.getRawTransaction.bind(Ct));const Ut=y.promisify(t.prototype.getTransaction.bind(Ct));const Gt=y.promisify(t.prototype.getNewAddress.bind(Ct));const Yt={createwallet:Ft,generateToAddress:Lt,getaddressinfo:Wt,getBlock:Bt,getBlockchainInfo:jt,getBlockHash:Dt,getRawTransaction:Kt,getTransaction:Ut,importaddress:y.promisify(t.prototype.importaddress.bind(Ct)),listunspent:y.promisify(t.prototype.listunspent.bind(Ct)),sendRawTransaction:y.promisify(t.prototype.sendRawTransaction.bind(Ct)),getNewAddress:Gt,sendToAddress:y.promisify(t.prototype.sendToAddress.bind(Ct))};const qt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:a,user:r,password:o}=e.cn;At.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${a}, user:${r}, password: ${o}`)}},noWarnings:!0};"dev"===pt&&ht>0&&(g.isAttached()?g.detach():(g.attach(qt),g.setTheme("matrix")));const zt=m(qt)({host:vt,port:St,database:wt,user:mt,password:gt,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Vt}=m;class Jt{static async select(t){const e=new Vt({name:`Input.select.${Math.random()}`,text:'SELECT "rev" FROM "Input" WHERE "rev" = $1',values:[t]});return zt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev]));for(;e.length;){const t=e.splice(0,It);const s=[];for(let e=1;e<=t.length;e+=1)s.push(`($${e})`);const n=s.join(",");const a=new Vt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("rev") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await zt.none(a)}}static async count(t){const e=t.map((t=>t.rev));const s=new Vt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "rev" LIKE ANY ($1)',values:[[e]]});const n=await zt.oneOrNone(s);return parseInt(n?.count,10)||0}}const{Transaction:Zt}=h;const{Input:Qt}=Zt;class Xt{static getNonCoinbaseRevs=t=>t.map((t=>Qt.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull())).map((({prevTxId:t,outputIndex:e})=>({rev:`${t.toString("hex")}/${e}`})));static insert=async t=>class{static async select(t){return Jt.select(t)}static async insert(t){return Jt.insert(t)}}.insert(this.getNonCoinbaseRevs(t))}const{PreparedStatement:te}=m;class ee{static async select(t){const e=new te({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return zt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey]));for(;e.length;){const t=e.splice(0,It);const s=[];for(let e=1;e<=t.length;e+=4)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const n=s.join(",");const a=new te({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await zt.none(a)}}}const{Script:se}=h;class ne{static insert=async(t,e)=>{const s=t.map(((t,s)=>{const n=se.fromBuffer(t._scriptBuffer);let a=n.toAddress(bt).toString("legacy");"false"===a&&(a=null);const r=n.toHex();const o=Math.round(t.satoshis);return{address:a,rev:`${e}/${s}`,scriptPubKey:r,satoshis:o}}));return class{static async select(t){return ee.select(t)}static async insert(t){return ee.insert(t)}}.insert(s)}}const{PreparedStatement:ae}=m;class re{static async query(t){const{publicKey:e,classHash:s}=t;if(void 0===e&&void 0===s)return[];let n='SELECT "rev"\n      FROM "NonStandard"\n      WHERE true ';const a=[];e&&(a.push(e),n+=' AND $1 = ANY ("publicKeys")'),s&&(a.push(s),n+=` AND "classHash" = $${a.length}`);const r=new ae({name:`NonStandard.query.${Math.random()}`,text:n,values:a});return(await zt.any(r)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,classHash:n}){const a=new ae({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash") VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING',values:[t,e,s,n]});await zt.none(a)}static async update({id:t,rev:e,publicKeys:s}){const n=new ae({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return zt.none(n)}static async getRevsByIds(t){const e=new ae({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return zt.any(e)}static async select(t){const e=new ae({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return zt.oneOrNone(e)}}class oe{static async select(t){return re.select(t)}static async query(t){return re.query(t)}static async getRevsByIds(t){return re.getRevsByIds(t)}static async insert(t){return re.insert(t)}static async update(t){return re.update(t)}}const{crypto:ce}=h;class ie{static add=async(t,e,s)=>{const n=Math.max(t.length,e.length);const a=Mt(t,n);const r=Mt(e,n);const o=(c=r,a.map(((t,e)=>[t,c[e]])));var c;await Promise.all(o.map((async([t,e],n)=>{const{__cls:a="",_owners:r=[]}=s[n]||{};if(null===t&&e)return/^[0-9A-Fa-f]{64}\/\d+$/.test(e),void await oe.insert({id:e,rev:e,publicKeys:r,classHash:ce.Hash.sha256(Buffer.from(a)).toString("hex")});if(e&&t){const{id:s,classHash:n}=await oe.select(t)||{};await oe.update({id:s,rev:e,publicKeys:r,classHash:n})}})))};static query=async t=>oe.query(t);static getRevsByIds=async t=>(await oe.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:de}=m;class fe{static async select(){return zt.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncStatus"')}static async update({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}){const n=new de({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,s]});await zt.any(n)}}class le{static async select(){return fe.select()}static async update(t){await fe.update(t)}}class ue{static updateSync=async t=>le.update(t);static selectSync=async()=>le.select()}const be=new a({chain:ut,network:bt,url:yt});class pe{static syncTx=async t=>{await ne.insert(t.tx.outputs,t.txId),await Xt.insert(t.tx.inputs);const{inRevs:e=[],outRevs:s=[],outData:n=[]}=t;await ie.add(e,s,n)};static rawTxSubscriber=async t=>{try{const e=t.toString("hex");At.info(`ZMQ message { rawTx:${e} }`),"dev"===pt&&r.appendFileSync("zmqlog.log",`${e} \r\n`);const s=await be.db.fromTxHex(e);try{await this.syncTx(s)}catch(t){At.error(`Error parsing transaction ${t.message} ${t.stack}`)}}catch(t){At.error(`RawTxSubscriber failed with error '${t.message} ${t.stack}'`)}};static checkSyncEnd=async()=>{let t=-1;let e=-1;let s=0;At.info("Checking sync progress...syncedHeight: -1 from -1");do{({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}=await ue.selectSync()),t>0?At.info(`Sync progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*s).toFixed(4)}%)]`):At.info(`Sync progress initializing... ${t}/${e} blocks `),await Pt(_t)}while(t<e||s<.999);At.info(`BCN reaches sync end...currentBlockHeight: ${t} from ${e} (chain progress: ${(100*s).toFixed(4)})`)};static createWallet=async()=>{try{await Yt.createwallet(Ot)}catch(t){At.debug(`Wallet creation failed with error '${t.message}'`)}};static sub=async t=>{try{await this.createWallet(),"regtest"!==bt&&await this.checkSyncEnd(),await(async()=>{if("LTC"===ut&&"regtest"===bt){At.info(`Node is starting for chain ${ut} and network ${bt}, Starting MWEB setup.`);const{result:t}=await Yt.getBlockchainInfo();const e=t.blocks;if(e<Ht){const{result:t}=await Yt.getNewAddress("","legacy");const s=Ht-e-1;s&&await Yt.generateToAddress(s,t);const{result:n}=await Yt.getNewAddress("mweb","mweb");await Yt.sendToAddress(n,1),await Yt.generateToAddress(1,t)}At.info("MWEB setup is complete")}})(),At.info(`Bitcoin Computer Node is ready ${Nt}`);for await(const[,e]of t)await this.rawTxSubscriber(e)}catch(t){At.error(`ZMQ subscription failed with error '${t.message}'`)}}}e.use(n);const{expect:ye}=e;afterEach((()=>{s.restore()})),describe("zmqsub",(()=>{describe("rawTxSubscriber",(()=>{it("Should ignore a standard rawtx",(async()=>{const e="01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0104ffffffff0100f2052a0100000043410496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858eeac00000000";const n="0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098";const a={txid:n,hash:"906c7434c759c8baf9bea2429a849942143cbed7bae22d34086bbfbafff2c582",version:1,vin:[],vout:[{value:50,n:0,scriptPubKey:{hex:"410496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858eeac",addresses:["12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX"]},txId:n}],nLockTime:0};const r={};r[e]=a;const o=s.stub(ne,"insert").resolves();const c=s.stub(ie,"add");const i=s.stub(t.prototype,"decodeRawTransaction").callsFake(((t,e)=>{e(null,{result:r[t]})}));await pe.rawTxSubscriber(e),ye(c.calledWith([],[],[])).to.be.true,c.restore(),i.restore(),o.restore()})),it("Should sync a coinbase testnet rawtx",(async()=>{const e="01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0b03c58c01062f503253482fffffffff0386600f27010000001976a914dde4906f870df11cf316b15adb628a3c3cc9883988ac8ab8f60200000000434104ffd03de44a6e11b9917f3a29f9443283d9871c9d743ef30d5eddcd37094b64d1b3d8090496b53256786bf5c82932ec23c3b74d9f05a6f95a8b5529352656664bac00000000000000002a6a28e73cd21eb4ac1eb1ba3767f4bf12be98935656451df3d6dee34c125662bcd599000000000000010000000000";const n=new a;const r=await n.db.fromTxHex(e);const o={};o[e]=r;const c=s.stub(ne,"insert").resolves();const i=s.stub(Xt,"insert").resolves();const d=s.stub(ie,"add").resolves();const f=s.stub(t.prototype,"decodeRawTransaction").callsFake(((t,e)=>{e(null,{result:o[t]})}));await pe.rawTxSubscriber(e),ye(c.calledWith(r.tx.outputs,r.tx.id)).to.be.true,ye(i.calledWith(r.tx.inputs)).to.be.true,ye(d.calledWith([],[],[])).to.be.true,f.restore(),c.restore(),i.restore(),d.restore()})),it("Should sync another coinbase testnet rawtx",(async()=>{const e="01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0b03c58c01062f503253482fffffffff0386600f27010000001976a914dde4906f870df11cf316b15adb628a3c3cc9883988ac8ab8f60200000000434104ffd03de44a6e11b9917f3a29f9443283d9871c9d743ef30d5eddcd37094b64d1b3d8090496b53256786bf5c82932ec23c3b74d9f05a6f95a8b5529352656664bac00000000000000002a6a28e73cd21eb4ac1eb1ba3767f4bf12be98935656451df3d6dee34c125662bcd599000000000000010000000000";const n=new a;const r=await n.db.fromTxHex(e);const o={};o[e]=r;const c=s.stub(ne,"insert").resolves();const i=s.stub(Xt,"insert").resolves();const d=s.stub(ie,"add").resolves();const f=s.stub(t.prototype,"decodeRawTransaction").callsFake(((t,e)=>{e(null,{result:o[t]})}));await pe.rawTxSubscriber(e),ye(c.calledWith(r.tx.outputs,r.tx.id)).to.be.true,ye(i.calledWith(r.tx.inputs)).to.be.true,ye(d.calledWith([],[],[])).to.be.true,f.restore(),c.restore(),i.restore(),d.restore()})),it.skip("Should sync a litecoin testnet rawtx",(async()=>{const e="02000000000102bde791c8ae9b1e76d4483ad62ec06eaaddf219e2c16af641a19b073611d909c700000000171600143360c64ee68f1417f2d31dbe31f957ba53e01c6dffffffffc5ab39b1c0498f0d4dbf7abe7f5ee93c507a20df5f92783e1b011733e634901e00000000171600143360c64ee68f1417f2d31dbe31f957ba53e01c6dffffffff010000000000000000536a4c50a6b3a966daaf4a01ba9eca5a3685caa8483f8dcf05c7e5c5597bbdc3f6f699bc3adcfc073cd4fd3d57fc1121ad088841575b52b8e19b4b4a9b9e31d27e67d99c532836e95ec2fb8c701accba0467e0ea0247304402205f935806661dd61bbba94a3392dff052e86b4c65e5edb69597e6600f2388d69202200af006b7115d7e717e567cd81bc9428974cc2fcca276c4c7ade629b447bf23510121023dbf03061b06a79495d9b0e8c04a5d3250855cfb29a7729e1f1b81e3230067e002473044022055352812e5b7e273544dedc14c1c9e70024f8f567e144e11c4f6e2325cc4b416022006d709acf2fb986dfb41bace9aca1fad96959d2ea81dabf557e6a4054f1641020121023dbf03061b06a79495d9b0e8c04a5d3250855cfb29a7729e1f1b81e3230067e000000000";const n=new a;const r=await n.db.fromTxHex(e);const o={};o[e]=r;const c=s.stub(ne,"insert").resolves();const i=s.stub(Xt,"insert").resolves();const d=s.stub(ie,"add").resolves();const f=s.stub(t.prototype,"decodeRawTransaction").callsFake(((t,e)=>{e(null,{result:o[t]})}));await pe.rawTxSubscriber(e),ye(c.calledWith(r.tx.outputs,r.tx.id)).to.be.true,ye(i.calledWith(r.tx.inputs)).to.be.true,ye(d.calledWith([],[],[])).to.be.true,f.restore(),c.restore(),i.restore(),d.restore()}))}))}));

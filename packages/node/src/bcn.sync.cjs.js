"use strict";var t=require("exponential-backoff");var e=require("@bitcoin-computer/lib");var n=require("dotenv");var s=require("is-primitive");var r=require("is-plain-object");var a=require("fs");var o=require("os");var i=require("path");var c=require("url");var l=require("winston");var d=require("bitcoind-rpc");var u=require("util");var p=require("pg-promise");var f=require("pg-monitor");var y=require("bitcoin-computer-bitcore");function h(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var g=h(n);var m=h(s);var v=h(r);var S=h(a);var b=h(o);var w=h(d);var E=h(u);var $=h(p);var T=h(f);const{deleteProperty:R}=Reflect;const H=m.default;const O=v.default;const N=t=>"object"==typeof t&&null!==t||"function"==typeof t;const _=t=>{if(!H(t))throw new TypeError("Object keys must be strings or symbols");if((t=>"__proto__"===t||"constructor"===t||"prototype"===t)(t))throw new Error(`Cannot set unsafe key: "${t}"`)};const A=(t,e)=>e&&"function"==typeof e.split?e.split(t):"symbol"==typeof t?[t]:Array.isArray(t)?t:((t,e,n)=>{const s=(t=>Array.isArray(t)?t.flat().map(String).join(","):t)(e?((t,e)=>{if("string"!=typeof t||!e)return t;let n=t+";";return void 0!==e.arrays&&(n+=`arrays=${e.arrays};`),void 0!==e.separator&&(n+=`separator=${e.separator};`),void 0!==e.split&&(n+=`split=${e.split};`),void 0!==e.merge&&(n+=`merge=${e.merge};`),void 0!==e.preservePaths&&(n+=`preservePaths=${e.preservePaths};`),n})(t,e):t);_(s);const r=P.cache.get(s)||n();return P.cache.set(s,r),r})(t,e,(()=>((t,e={})=>{const n=e.separator||".";const s="/"!==n&&e.preservePaths;if("string"==typeof t&&!1!==s&&/\//.test(t))return[t];const r=[];let a="";const o=t=>{let e;""!==t.trim()&&Number.isInteger(e=Number(t))?r.push(e):r.push(t)};for(let e=0;e<t.length;e++){const s=t[e];"\\"!==s?s!==n?a+=s:(o(a),a=""):a+=t[++e]}return a&&o(a),r})(t,e)));const x=(t,e,n,s)=>{if(_(e),void 0===n)R(t,e);else if(s&&s.merge){const r="function"===s.merge?s.merge:Object.assign;r&&O(t[e])&&O(n)?t[e]=r(t[e],n):t[e]=n}else t[e]=n;return t};const P=(t,e,n,s)=>{if(!e||!N(t))return t;const r=A(e,s);let a=t;for(let t=0;t<r.length;t++){const e=r[t];const o=r[t+1];if(_(e),void 0===o){x(a,e,n,s);break}"number"!=typeof o||Array.isArray(a[e])?(N(a[e])||(a[e]={}),a=a[e]):a=a[e]=[]}return t};P.split=A,P.cache=new Map,P.clear=()=>{P.cache=new Map};var I=P;var k=S.default;var F="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var M="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var B=function(){function t(t,e){for(var n=0;n<e.length;n++){var s=e[n];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(t,s.key,s)}}return function(e,n,s){return n&&t(e.prototype,n),s&&t(e,s),e}}();var C=function t(e,n){var s=n.indexOf(".");if(!~s){if(null==e)return;return e[n]}var r=n.substring(0,s),a=n.substring(s+1);if(null!=e)return e=e[r],a?t(e,a):e},L=I,U=function(t,e){if("function"!=typeof e)return JSON.parse(k.readFileSync(t));k.readFile(t,"utf-8",(function(t,n){try{n=JSON.parse(n)}catch(e){t=t||e}e(t,n)}))},D=S.default,j=b.default;var q=function(){function t(e,n){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.options=n=n||{},n.stringify_width=n.stringify_width||2,n.stringify_fn=n.stringify_fn||null,n.stringify_eol=n.stringify_eol||!1,n.ignore_dots=n.ignore_dots||!1,this.path=e,this.data=this.read()}return B(t,[{key:"set",value:function(t,e,n){var s=this;return"object"===(void 0===t?"undefined":M(t))?function(t,e){var n=0,s=[];if(Array.isArray(t))for(;n<t.length&&!1!==e(t[n],n);++n);else if("object"===(void 0===t?"undefined":F(t))&&null!==t)for(s=Object.keys(t);n<s.length&&!1!==e(t[s[n]],s[n]);++n);}(t,(function(t,e){L(s.data,e,t,n)})):this.options.ignore_dots?this.data[t]=e:L(this.data,t,e,n),this.options.autosave&&this.save(),this}},{key:"get",value:function(t){return t?this.options.ignore_dots?this.data[t]:C(this.data,t):this.toObject()}},{key:"unset",value:function(t){return this.set(t,void 0)}},{key:"append",value:function(t,e){var n=this.get(t);if(n=void 0===n?[]:n,!Array.isArray(n))throw new Error("The data is not an array!");return n.push(e),this.set(t,n),this}},{key:"pop",value:function(t){var e=this.get(t);if(!Array.isArray(e))throw new Error("The data is not an array!");return e.pop(),this.set(t,e),this}},{key:"read",value:function(t){if(!t)try{return U(this.path)}catch(t){return{}}U(this.path,(function(e,n){t(null,n=e?{}:n)}))}},{key:"write",value:function(t,e){return e?D.writeFile(this.path,t,e):D.writeFileSync(this.path,t),this}},{key:"empty",value:function(t){return this.write("{}",t)}},{key:"save",value:function(t){var e=JSON.stringify(this.data,this.options.stringify_fn,this.options.stringify_width,this.options.stringify_eol);return this.write(this.options.stringify_eol?e+j.EOL:e,t),this}},{key:"toObject",value:function(){return this.data}}]),t}();g.default.config();const K=function(t,e){return new q(t,{stringify_eol:!0})}(`${i.dirname(c.fileURLToPath("undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("bcn.sync.cjs.js",document.baseURI).href))}/../../package.json`);const{PORT:G,ZMQ_URL:W,CHAIN:Y,NETWORK:V,BCN_ENV:z,BCN_URL:J,DEBUG_MODE:Z,POSTGRES_USER:Q,POSTGRES_PASSWORD:X,POSTGRES_DB:tt,POSTGRES_HOST:et,POSTGRES_PORT:nt,RPC_PROTOCOL:st,RPC_USER:rt,RPC_PASSWORD:at,RPC_HOST:ot,RPC_PORT:it,SERVER_VERSION:ct,TESTING:lt,DEFAULT_WALLET:dt,SYNC_HEIGHT:ut,SYNC_INTERVAL_CHECK:pt,POSTGRES_MAX_PARAM_NUM:ft,DB_CONNECTION_RETRY_TIME:yt,SIGNATURE_FRESHNESS_MINUTES:ht,ALLOWED_RPC_METHODS:gt}=process.env;const mt=Y||"LTC";const vt=V||"regtest";const St=z||"dev";const bt=J||"http://127.0.0.1:3000";const wt=parseInt(Z,10)||1;const Et=Q||"bcn";const $t=X||"bcn";const Tt=tt||"bcn";const Rt=et||"127.0.0.1";const Ht=parseInt(nt,10)||"5432";const Ot=st||"http";const Nt=rt||"bcn-admin";const _t=at||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const At=ot||"node";const xt=parseInt(it,10)||19332;ct||K.get("version");const Pt=parseInt(ut,10)||1;const It=parseInt(ft,10)||1e4;const kt=parseInt(yt,10)||500;!gt||gt.split(",").map((t=>new RegExp(t)));const Ft=l.createLogger({level:["error","warn","info","http","verbose","debug","silly"][wt],format:l.format.json(),transports:[new l.transports.Console({format:l.format.combine(l.format.colorize(),l.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),l.format.printf((t=>`[2m${t.timestamp}[0m ${t.level} ${t.message}`)))})],exceptionHandlers:[new l.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new l.transports.File({filename:"logs/rejections.log"})]});const Mt={maxFiles:1,maxSize:1e5};wt>=0&&Ft.add(new l.transports.File({filename:"error.log",level:"error"})),wt>=1&&Ft.add(new l.transports.File({filename:"logs/warn.log",level:"warn",...Mt})),wt>=2&&Ft.add(new l.transports.File({filename:"logs/info.log",level:"info",...Mt})),wt>=3&&Ft.add(new l.transports.File({filename:"logs/http.log",level:"http",...Mt})),wt>=4&&Ft.add(new l.transports.File({filename:"logs/verbose.log",level:"verbose",...Mt})),wt>=5&&Ft.add(new l.transports.File({filename:"logs/debug.log",level:"debug",...Mt}));const Bt={protocol:Ot,user:Nt,pass:_t,host:At,port:xt};const Ct=new w.default(Bt);const Lt={createwallet:E.default.promisify(w.default.prototype.createwallet.bind(Ct)),generateToAddress:E.default.promisify(w.default.prototype.generateToAddress.bind(Ct)),getaddressinfo:E.default.promisify(w.default.prototype.getaddressinfo.bind(Ct)),getBlock:E.default.promisify(w.default.prototype.getBlock.bind(Ct)),getBlockchainInfo:E.default.promisify(w.default.prototype.getBlockchainInfo.bind(Ct)),getBlockHash:E.default.promisify(w.default.prototype.getBlockHash.bind(Ct)),getRawTransaction:E.default.promisify(w.default.prototype.getRawTransaction.bind(Ct)),getTransaction:E.default.promisify(w.default.prototype.getTransaction.bind(Ct)),importaddress:E.default.promisify(w.default.prototype.importaddress.bind(Ct)),listunspent:E.default.promisify(w.default.prototype.listunspent.bind(Ct)),sendRawTransaction:E.default.promisify(w.default.prototype.sendRawTransaction.bind(Ct))};const Ut=(t,e)=>Object.assign(new Array(e).fill(null),t);const Dt={error:(t,e)=>{if(e.cn){const{host:n,port:s,database:r,user:a,password:o}=e.cn;Ft.debug(`Waiting for db to start { message:${t.message} host:${n}, port:${s}, database:${r}, user:${a}, password: ${o}`)}},noWarnings:!0};"dev"===St&&wt>0&&(T.default.isAttached()?T.default.detach():(T.default.attach(Dt),T.default.setTheme("matrix")));const jt=$.default(Dt)({host:Rt,port:Ht,database:Tt,user:Et,password:$t,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:qt}=$.default;class Kt{static async select(){return jt.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "Sync"')}static async update({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:n}){const s=new qt({name:`Sync.update.${Math.random()}`,text:'UPDATE "Sync" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,n]});await jt.any(s)}}class Gt{static async select(){return Kt.select()}static async update(t){await Kt.update(t)}}var Wt=async()=>Gt.select();var Yt=async t=>{await Gt.update(t)};const{PreparedStatement:Vt}=$.default;class zt{static async select(t){const e=new Vt({name:`Standard.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Standard" WHERE "address" = $1 AND "spent" = FALSE',values:[t]});return(await jt.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)})))}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,!1]));for(;e.length;){const t=e.splice(0,It);const n=[];for(let e=1;e<=t.length;e+=5)n.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4})`);const s=n.join(",");const r=new Vt({name:`Standard.insert.${Math.random()}`,text:`INSERT INTO "Standard"("rev", "address", "satoshis", "scriptPubKey", "spent") VALUES ${s}  ON CONFLICT DO NOTHING`,values:t});await jt.none(r)}}static async update(t){const e=t.flatMap((t=>[`${t.prevTxId.toString("hex")}/${t.outputIndex}`]));if(0===e.length)return[];const n=[];for(let t=1;t<=e.length;t+=1)n.push(`("rev" = $${t})`);const s=n.join(" OR ");const r=new Vt({name:`Standard.update.${Math.random()}`,text:`UPDATE "Standard" SET "spent" = TRUE WHERE ${s} RETURNING "rev"`,values:e});return jt.any(r)}static async getBalance(t){const e=new Vt({name:`Standard.getBalance.${Math.random()}`,text:'SELECT SUM("satoshis") FROM "Standard" WHERE "address" = $1 AND "spent" = FALSE',values:[t]});const n=await jt.oneOrNone(e);return parseInt(n?.sum,10)||0}}const{Transaction:Jt}=y.Bitcoin;const{Input:Zt}=Jt;var Qt=async t=>{const e=t.map((t=>Zt.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));return zt.update(e)};const{Script:Xt,Transaction:te}=y.Bitcoin;var ee=async(t,e)=>{const n=t.flatMap(((t,n)=>{const s=Xt.fromBuffer(t._scriptBuffer);const{PUBKEYHASH_OUT:r,SCRIPTHASH_OUT:a}=Xt.types;if(![r,a].includes(s.classify()))return[];const o=s.toAddress(vt).toString("legacy");const i=s.toHex();const c=t.satoshis/1e8;const l=Math.round(t.satoshis);return[new te.UnspentOutput({address:o,txId:e,outputIndex:n,scriptPubKey:i,amount:c,satoshis:l})]}));await class{static async select(t){return(await zt.select(t)).map((t=>({...t,amount:t.satoshis/1e8})))}static async getBalance(t){return zt.getBalance(t)}static async insert(t){const e=t.map((t=>({rev:`${t.txId}/${t.outputIndex}`,address:t.address.toString("legacy"),satoshis:t.satoshis,scriptPubKey:t.script.toHex(),spent:!1})));return zt.insert(e)}}.insert(n)};const{PreparedStatement:ne}=$.default;class se{static async query(t){const{publicKey:e,classHash:n}=t;if(void 0===e&&void 0===n)return[];let s='SELECT "rev"\n      FROM "NonStandard"\n      WHERE "spent" = FALSE';const r=[];e&&(r.push(e),s+=' AND $1 = ANY ("publicKeys")'),n&&(r.push(n),s+=` AND "classHash" = $${r.length}`);const a=new ne({name:`NonStandard.query.${Math.random()}`,text:s,values:r});return(await jt.any(a)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:n,classHash:s}){const r=new ne({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash", "spent") VALUES ($1, $2, $3, $4, FALSE) ON CONFLICT DO NOTHING',values:[t,e,n,s]});await jt.none(r)}static async update(t){const e=new ne({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "spent" = TRUE WHERE "rev" = $1 AND "spent" = FALSE',values:[t]});return jt.none(e)}static async getRevsByIds(t){const e=new ne({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1) AND "spent" = FALSE',values:[[t]]});return jt.any(e)}static async select(t){const e=new ne({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return jt.oneOrNone(e)}}class re{static async select(t){return se.select(t)}static async query(t){return se.query(t)}static async getRevsByIds(t){return se.getRevsByIds(t)}static async insert(t){return se.insert(t)}static async update(t){return se.update(t)}}const{crypto:ae}=y.Bitcoin;var oe=async(t,e,n)=>{const s=Math.max(t.length,e.length);const r=Ut(t,s);const a=Ut(e,s);const o=(i=a,r.map(((t,e)=>[t,i[e]])));var i;await Promise.all(o.map((async([t,e],s)=>{const{__cls:r="",_owners:a=[]}=n[s]||{};if(null===t&&e)return/^[0-9A-Fa-f]{64}\/\d+$/.test(e),void await re.insert({id:e,rev:e,publicKeys:a,classHash:ae.Hash.sha256(Buffer.from(r)).toString("hex")});if(e&&t){const{id:n="",classHash:s=""}=await re.select(t)||{};await re.insert({id:n,classHash:s,rev:e,publicKeys:a}),await re.update(t)}})))};var ie=async t=>{for(let e=0;e<t.length;e+=1)try{const{tx:n,txId:s,inRevs:r=[],outRevs:a=[],outData:o=[]}=t[e];await ee(n.outputs,n.id),await Qt(n.inputs),await oe(r,a,o),Ft.info(`Synced to '${s}'`)}catch(n){n.message.includes("duplicate key value violates unique constraint")||Ft.error(`Processing tx ${t[e].tx.id} failed with error '${n.message}'`)}};const ce=new e.Computer({chain:mt,network:vt,url:bt});const le=async(t,e,n)=>{try{let{result:s}=await Lt.getBlockHash(t);for(;t<=e;){const{result:r}=await Lt.getBlock(s,2);const{tx:a,nextblockhash:o}=r;const i=`Backfilling progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*n).toFixed(4)}%)] Backfilling ${a.length} transactions...`;Ft.info(i);const c=[];for(let e=0;e<a.length;e+=1)try{const t=await ce.db.fromTxHex(a[e].hex);c.push(t)}catch(n){Ft.error(`Error [sync.action]: fromTxHex failed. Height: ${t} - tx: ${a[e].hex} - error:  ${n.message}`)}await ie(c),await Yt({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:n}),s=o,t+=1}}catch(t){Ft.error(`Sync action failed with error '${t.message}'`)}};!function(){try{const e=`Synchronizing { url: ${bt}, chain:${mt} network:${vt} }`;Ft.info(e),"regtest"!==vt&&(async()=>{await(async()=>{await t.backOff((()=>jt.connect()),{startingDelay:kt})})(),await(async()=>{try{let e=await t.backOff((()=>(async()=>{const t=await Lt.getBlockchainInfo();const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const{blocks:n}=t.result;const s=`Bitcoind Synced Progress { percentage:${e}%, blocks:${n} }`;if(Ft.info(s),parseFloat(t.result.verificationprogress)<=1e-6)throw new Error("Node not ready yet");return t})()),{startingDelay:5e3,timeMultiple:1,numOfAttempts:720});let n=await Wt();await Yt({syncedHeight:n.syncedHeight,bitcoindSyncedHeight:e.result.blocks,bitcoindSyncedProgress:e.result.verificationprogress});let s=Math.max(Pt,n.syncedHeight+1);const r=(100*parseFloat(e.result.verificationprogress)).toFixed(4);const a=e.result.blocks;const{syncedHeight:o}=n;const i=`Starting sync process { bitcoind.progress:${r}%, bitcoindSyncedHeight:${a}, syncedHeight:${o}, currentBlockHeight:${s} }`;for(Ft.info(i);parseFloat(e.result.verificationprogress)<.999||s<=n.bitcoindSyncedHeight;){await le(s,n.bitcoindSyncedHeight,e.result.verificationprogress),e=await Lt.getBlockchainInfo(),n=await Wt(),n.bitcoindSyncedHeight=e.result.blocks,await Yt({syncedHeight:n.syncedHeight,bitcoindSyncedHeight:n.bitcoindSyncedHeight,bitcoindSyncedProgress:e.result.verificationprogress});const t=(100*parseFloat(e.result.verificationprogress)).toFixed(4);Ft.info(`Bitcoind progress: ${t}%`),s=n.syncedHeight+1}}catch(t){Ft.error(`Sync action failed with error '${t.message}'`)}})()})()}catch(t){Ft.error(`Synchronizing failed with error '${t.message}'`)}}();

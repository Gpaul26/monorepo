import{backOff as t}from"exponential-backoff";import{Computer as e}from"@bitcoin-computer/lib";import s from"dotenv";import n from"is-primitive";import r from"is-plain-object";import o from"fs";import i from"os";import{dirname as a}from"path";import{fileURLToPath as c}from"url";import{createLogger as l,format as d,transports as p}from"winston";import u from"bitcoind-rpc";import y from"util";import f from"pg-promise";import h from"pg-monitor";import g from"@bitcoin-computer/bitcore-lib-ltc";const{deleteProperty:m}=Reflect;const v=n;const S=r;const b=t=>"object"==typeof t&&null!==t||"function"==typeof t;const w=t=>{if(!v(t))throw new TypeError("Object keys must be strings or symbols");if((t=>"__proto__"===t||"constructor"===t||"prototype"===t)(t))throw new Error(`Cannot set unsafe key: "${t}"`)};const $=(t,e)=>e&&"function"==typeof e.split?e.split(t):"symbol"==typeof t?[t]:Array.isArray(t)?t:((t,e,s)=>{const n=(t=>Array.isArray(t)?t.flat().map(String).join(","):t)(e?((t,e)=>{if("string"!=typeof t||!e)return t;let s=t+";";return void 0!==e.arrays&&(s+=`arrays=${e.arrays};`),void 0!==e.separator&&(s+=`separator=${e.separator};`),void 0!==e.split&&(s+=`split=${e.split};`),void 0!==e.merge&&(s+=`merge=${e.merge};`),void 0!==e.preservePaths&&(s+=`preservePaths=${e.preservePaths};`),s})(t,e):t);w(n);const r=T.cache.get(n)||s();return T.cache.set(n,r),r})(t,e,(()=>((t,e={})=>{const s=e.separator||".";const n="/"!==s&&e.preservePaths;if("string"==typeof t&&!1!==n&&/\//.test(t))return[t];const r=[];let o="";const i=t=>{let e;""!==t.trim()&&Number.isInteger(e=Number(t))?r.push(e):r.push(t)};for(let e=0;e<t.length;e++){const n=t[e];"\\"!==n?n!==s?o+=n:(i(o),o=""):o+=t[++e]}return o&&i(o),r})(t,e)));const E=(t,e,s,n)=>{if(w(e),void 0===s)m(t,e);else if(n&&n.merge){const r="function"===n.merge?n.merge:Object.assign;r&&S(t[e])&&S(s)?t[e]=r(t[e],s):t[e]=s}else t[e]=s;return t};const T=(t,e,s,n)=>{if(!e||!b(t))return t;const r=$(e,n);let o=t;for(let t=0;t<r.length;t++){const e=r[t];const i=r[t+1];if(w(e),void 0===i){E(o,e,s,n);break}"number"!=typeof i||Array.isArray(o[e])?(b(o[e])||(o[e]={}),o=o[e]):o=o[e]=[]}return t};T.split=$,T.cache=new Map,T.clear=()=>{T.cache=new Map};var O=T;var H=o;var N="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var R="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};var _=function(){function t(t,e){for(var s=0;s<e.length;s++){var n=e[s];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,s,n){return s&&t(e.prototype,s),n&&t(e,n),e}}();var I=function t(e,s){var n=s.indexOf(".");if(!~n){if(null==e)return;return e[s]}var r=s.substring(0,n),o=s.substring(n+1);if(null!=e)return e=e[r],o?t(e,o):e},x=O,A=function(t,e){if("function"!=typeof e)return JSON.parse(H.readFileSync(t));H.readFile(t,"utf-8",(function(t,s){try{s=JSON.parse(s)}catch(e){t=t||e}e(t,s)}))},P=o,k=i;var F=function(){function t(e,s){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.options=s=s||{},s.stringify_width=s.stringify_width||2,s.stringify_fn=s.stringify_fn||null,s.stringify_eol=s.stringify_eol||!1,s.ignore_dots=s.ignore_dots||!1,this.path=e,this.data=this.read()}return _(t,[{key:"set",value:function(t,e,s){var n=this;return"object"===(void 0===t?"undefined":R(t))?function(t,e){var s=0,n=[];if(Array.isArray(t))for(;s<t.length&&!1!==e(t[s],s);++s);else if("object"===(void 0===t?"undefined":N(t))&&null!==t)for(n=Object.keys(t);s<n.length&&!1!==e(t[n[s]],n[s]);++s);}(t,(function(t,e){x(n.data,e,t,s)})):this.options.ignore_dots?this.data[t]=e:x(this.data,t,e,s),this.options.autosave&&this.save(),this}},{key:"get",value:function(t){return t?this.options.ignore_dots?this.data[t]:I(this.data,t):this.toObject()}},{key:"unset",value:function(t){return this.set(t,void 0)}},{key:"append",value:function(t,e){var s=this.get(t);if(s=void 0===s?[]:s,!Array.isArray(s))throw new Error("The data is not an array!");return s.push(e),this.set(t,s),this}},{key:"pop",value:function(t){var e=this.get(t);if(!Array.isArray(e))throw new Error("The data is not an array!");return e.pop(),this.set(t,e),this}},{key:"read",value:function(t){if(!t)try{return A(this.path)}catch(t){return{}}A(this.path,(function(e,s){t(null,s=e?{}:s)}))}},{key:"write",value:function(t,e){return e?P.writeFile(this.path,t,e):P.writeFileSync(this.path,t),this}},{key:"empty",value:function(t){return this.write("{}",t)}},{key:"save",value:function(t){var e=JSON.stringify(this.data,this.options.stringify_fn,this.options.stringify_width,this.options.stringify_eol);return this.write(this.options.stringify_eol?e+k.EOL:e,t),this}},{key:"toObject",value:function(){return this.data}}]),t}();s.config();const M=new F(`${a(c(import.meta.url))}/../../package.json`,{stringify_eol:!0});const{PORT:C,ZMQ_URL:B,CHAIN:L,NETWORK:D,BCN_ENV:j,BCN_URL:K,DEBUG_MODE:U,POSTGRES_USER:W,POSTGRES_PASSWORD:G,POSTGRES_DB:Y,POSTGRES_HOST:q,POSTGRES_PORT:V,RPC_PROTOCOL:z,RPC_USER:J,RPC_PASSWORD:Z,RPC_HOST:Q,RPC_PORT:X,SERVER_VERSION:tt,DEFAULT_WALLET:et,SYNC_HEIGHT:st,SYNC_INTERVAL_CHECK:nt,POSTGRES_MAX_PARAM_NUM:rt,DB_CONNECTION_RETRY_TIME:ot,SIGNATURE_FRESHNESS_MINUTES:it,ALLOWED_RPC_METHODS:at,MWEB_HEIGHT:ct}=process.env;const lt=L||"LTC";const dt=D||"regtest";const pt=j||"dev";const ut=K||"http://127.0.0.1:3000";const yt=parseInt(U,10)||1;const ft=W||"bcn";const ht=G||"bcn";const gt=Y||"bcn";const mt=q||"127.0.0.1";const vt=parseInt(V,10)||"5432";const St=z||"http";const bt=J||"bcn-admin";const wt=Z||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const $t=Q||"node";const Et=parseInt(X,10)||19332;tt||M.get("version");const Tt=parseInt(st,10)||1;const Ot=parseInt(rt,10)||1e4;const Ht=parseInt(ot,10)||500;!at||at.split(",").map((t=>new RegExp(t)));const Nt=l({level:["error","warn","info","http","verbose","debug","silly"][yt],format:d.json(),transports:[new p.Console({format:d.combine(d.colorize(),d.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),d.printf((t=>`[2m${t.timestamp}[0m ${t.level} ${t.message}`)))})],exceptionHandlers:[new p.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new p.File({filename:"logs/rejections.log"})]});const Rt={maxFiles:1,maxSize:1e5};yt>=0&&Nt.add(new p.File({filename:"error.log",level:"error"})),yt>=1&&Nt.add(new p.File({filename:"logs/warn.log",level:"warn",...Rt})),yt>=2&&Nt.add(new p.File({filename:"logs/info.log",level:"info",...Rt})),yt>=3&&Nt.add(new p.File({filename:"logs/http.log",level:"http",...Rt})),yt>=4&&Nt.add(new p.File({filename:"logs/verbose.log",level:"verbose",...Rt})),yt>=5&&Nt.add(new p.File({filename:"logs/debug.log",level:"debug",...Rt}));const _t=new u({protocol:St,user:bt,pass:wt,host:$t,port:Et});const It=y.promisify(u.prototype.createwallet.bind(_t));const xt=y.promisify(u.prototype.generateToAddress.bind(_t));const At=y.promisify(u.prototype.getaddressinfo.bind(_t));const Pt=y.promisify(u.prototype.getBlock.bind(_t));const kt=y.promisify(u.prototype.getBlockchainInfo.bind(_t));const Ft=y.promisify(u.prototype.getBlockHash.bind(_t));const Mt=y.promisify(u.prototype.getRawTransaction.bind(_t));const Ct=y.promisify(u.prototype.getTransaction.bind(_t));const Bt=y.promisify(u.prototype.getNewAddress.bind(_t));const Lt={createwallet:It,generateToAddress:xt,getaddressinfo:At,getBlock:Pt,getBlockchainInfo:kt,getBlockHash:Ft,getRawTransaction:Mt,getTransaction:Ct,importaddress:y.promisify(u.prototype.importaddress.bind(_t)),listunspent:y.promisify(u.prototype.listunspent.bind(_t)),sendRawTransaction:y.promisify(u.prototype.sendRawTransaction.bind(_t)),getNewAddress:Bt,sendToAddress:y.promisify(u.prototype.sendToAddress.bind(_t))};const Dt=(t,e)=>Object.assign(new Array(e).fill(null),t);const jt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:r,user:o,password:i}=e.cn;Nt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${r}, user:${o}, password: ${i}`)}},noWarnings:!0};"dev"===pt&&yt>0&&(h.isAttached()?h.detach():(h.attach(jt),h.setTheme("matrix")));const Kt=f(jt)({host:mt,port:vt,database:gt,user:ft,password:ht,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Ut}=f;class Wt{static async select(){return Kt.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncStatus"')}static async update({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}){const n=new Ut({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,s]});await Kt.any(n)}}class Gt{static async select(){return Wt.select()}static async update(t){await Wt.update(t)}}class Yt{static updateSync=async t=>Gt.update(t);static selectSync=async()=>Gt.select()}const{PreparedStatement:qt}=f;class Vt{static async query(t){const{publicKey:e,classHash:s}=t;if(void 0===e&&void 0===s)return[];let n='SELECT "rev"\n      FROM "NonStandard"\n      WHERE true ';const r=[];e&&(r.push(e),n+=' AND $1 = ANY ("publicKeys")'),s&&(r.push(s),n+=` AND "classHash" = $${r.length}`);const o=new qt({name:`NonStandard.query.${Math.random()}`,text:n,values:r});return(await Kt.any(o)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,classHash:n}){const r=new qt({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash") VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING',values:[t,e,s,n]});await Kt.none(r)}static async update({id:t,rev:e,publicKeys:s}){const n=new qt({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return Kt.none(n)}static async getRevsByIds(t){const e=new qt({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return Kt.any(e)}static async select(t){const e=new qt({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return Kt.oneOrNone(e)}}class zt{static async select(t){return Vt.select(t)}static async query(t){return Vt.query(t)}static async getRevsByIds(t){return Vt.getRevsByIds(t)}static async insert(t){return Vt.insert(t)}static async update(t){return Vt.update(t)}}const{crypto:Jt}=g;class Zt{static add=async(t,e,s)=>{const n=Math.max(t.length,e.length);const r=Dt(t,n);const o=Dt(e,n);const i=(a=o,r.map(((t,e)=>[t,a[e]])));var a;await Promise.all(i.map((async([t,e],n)=>{const{__cls:r="",_owners:o=[]}=s[n]||{};if(null===t&&e)return/^[0-9A-Fa-f]{64}\/\d+$/.test(e),void await zt.insert({id:e,rev:e,publicKeys:o,classHash:Jt.Hash.sha256(Buffer.from(r)).toString("hex")});if(e&&t){const{id:s,classHash:n}=await zt.select(t)||{};await zt.update({id:s,rev:e,publicKeys:o,classHash:n})}})))};static query=async t=>zt.query(t);static getRevsByIds=async t=>(await zt.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:Qt}=f;class Xt{static async select(t){const e=new Qt({name:`Input.select.${Math.random()}`,text:'SELECT "rev" FROM "Input" WHERE "rev" = $1',values:[t]});return Kt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev]));for(;e.length;){const t=e.splice(0,Ot);const s=[];for(let e=1;e<=t.length;e+=1)s.push(`($${e})`);const n=s.join(",");const r=new Qt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("rev") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await Kt.none(r)}}static async count(t){const e=t.map((t=>t.rev));const s=new Qt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "rev" LIKE ANY ($1)',values:[[e]]});const n=await Kt.oneOrNone(s);return parseInt(n?.count,10)||0}}const{Transaction:te}=g;const{Input:ee}=te;class se{static getNonCoinbaseRevs=t=>t.map((t=>ee.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull())).map((({prevTxId:t,outputIndex:e})=>({rev:`${t.toString("hex")}/${e}`})));static insert=async t=>class{static async select(t){return Xt.select(t)}static async insert(t){return Xt.insert(t)}}.insert(this.getNonCoinbaseRevs(t))}const{PreparedStatement:ne}=f;class re{static async select(t){const e=new ne({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return Kt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey]));for(;e.length;){const t=e.splice(0,Ot);const s=[];for(let e=1;e<=t.length;e+=4)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const n=s.join(",");const r=new ne({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await Kt.none(r)}}}const{Script:oe}=g;class ie{static insert=async(t,e)=>{const s=t.map(((t,s)=>{const n=oe.fromBuffer(t._scriptBuffer);let r=n.toAddress(dt).toString("legacy");"false"===r&&(r=null);const o=n.toHex();const i=Math.round(t.satoshis);return{address:r,rev:`${e}/${s}`,scriptPubKey:o,satoshis:i}}));return class{static async select(t){return re.select(t)}static async insert(t){return re.insert(t)}}.insert(s)}}const ae=new e({chain:lt,network:dt,url:ut});class ce{static partialSync=async(t,e,s)=>{try{let{result:n}=await Lt.getBlockHash(t);for(;t<=e;){const{result:r}=await Lt.getBlock(n,2);const{tx:o,nextblockhash:i}=r;const a=`Backfilling progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*s).toFixed(4)}%)] Backfilling ${o.length} transactions...`;Nt.info(a);const c=[];for(let e=0;e<o.length;e+=1)try{const t=await ae.db.fromTxHex(o[e].hex);c.push(t)}catch(s){Nt.error(`Error [sync.action]: fromTxHex failed. Height: ${t} - tx: ${o[e].hex} - error:  ${s.message}`)}await this.syncTxs(c),await Yt.updateSync({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}),n=i,t+=1}}catch(t){Nt.error(`Sync action failed with error '${t.message}'`)}};static waitForNode=async()=>{const t=await Lt.getBlockchainInfo();const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const{blocks:s}=t.result;const n=`Bitcoind Synced Progress { percentage:${e}%, blocks:${s} }`;if(Nt.info(n),parseFloat(t.result.verificationprogress)<=1e-6)throw new Error("Node not ready yet");return t};static sync=async()=>{try{let e=await t((()=>this.waitForNode()),{startingDelay:5e3,timeMultiple:1,numOfAttempts:720});let s=await Yt.selectSync();await Yt.updateSync({syncedHeight:s.syncedHeight,bitcoindSyncedHeight:e.result.blocks,bitcoindSyncedProgress:e.result.verificationprogress});let n=Math.max(Tt,s.syncedHeight+1);const r=(100*parseFloat(e.result.verificationprogress)).toFixed(4);const o=e.result.blocks;const{syncedHeight:i}=s;const a=`Starting sync process { bitcoind.progress:${r}%, bitcoindSyncedHeight:${o}, syncedHeight:${i}, currentBlockHeight:${n} }`;for(Nt.info(a);parseFloat(e.result.verificationprogress)<.999||n<=s.bitcoindSyncedHeight;){await this.partialSync(n,s.bitcoindSyncedHeight,e.result.verificationprogress),e=await Lt.getBlockchainInfo(),s=await Yt.selectSync(),s.bitcoindSyncedHeight=e.result.blocks,await Yt.updateSync({syncedHeight:s.syncedHeight,bitcoindSyncedHeight:s.bitcoindSyncedHeight,bitcoindSyncedProgress:e.result.verificationprogress});const t=(100*parseFloat(e.result.verificationprogress)).toFixed(4);Nt.info(`Bitcoind progress: ${t}%`),n=s.syncedHeight+1}}catch(t){Nt.error(`Sync action failed with error '${t.message}'`)}};static syncTxs=async t=>{for(let e=0;e<t.length;e+=1)try{const{tx:s,txId:n,inRevs:r=[],outRevs:o=[],outData:i=[]}=t[e];await ie.insert(s.outputs,s.id),await se.insert(s.inputs),await Zt.add(r,o,i),Nt.info(`Synced to '${n}'`)}catch(s){s.message.includes("duplicate key value violates unique constraint")||Nt.error(`Processing tx ${t[e].tx.id} failed with error '${s.message}'`)}}}!function(){try{const e=`Synchronizing { url: ${ut}, chain:${lt} network:${dt} }`;Nt.info(e),"regtest"!==dt&&(async()=>{await(async()=>{await t((()=>Kt.connect()),{startingDelay:Ht})})(),await ce.sync()})()}catch(t){Nt.error(`Synchronizing failed with error '${t.message}'`)}}();

import{Buffer as t}from"buffer";import e from"@bitcoin-computer/bitcore-mnemonic-ltc";import r from"axios";import{randomBytes as n}from"crypto";import i from"crypto-js";import{encrypt as o,decrypt as s}from"eciesjs";import{StaticModuleRecord as a}from"@endo/static-module-record";import"ses";const u="LTC",c="testnet";var l=t;const{crypto:p}=e.bitcore,f=(t,e)=>{const r=Date.now(),n=p.Hash.sha256(l.from(e+r)),i=[p.ECDSA.sign(n,t,"big").toString("hex"),t.publicKey.toString(),r];return`Bearer ${l.from(i.join(":")).toString("base64")}`};function h(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}class d{constructor(t="https://node.bitcoincomputer.io",r=new e.bitcore.PrivateKey,n={}){h(this,"baseUrl",void 0),h(this,"headers",void 0),h(this,"privateKey",void 0),this.baseUrl=t,this.headers=n,this.privateKey=r}async get(t){const e=this.privateKey?{Authentication:f(this.privateKey,this.baseUrl)}:{};return(await r.get(`${this.baseUrl}${t}`,{headers:{...this.headers,...e}})).data}async post(t,e){const n=this.privateKey?{Authentication:f(this.privateKey,this.baseUrl)}:{};return(await r.post(`${this.baseUrl}${t}`,e,{headers:{...this.headers,...n}})).data}async delete(t){const e=this.privateKey?{Authentication:f(this.privateKey,this.baseUrl)}:{};return(await r.delete(`${this.baseUrl}${t}`,{headers:{...this.headers,...e}})).data}}parseInt("",10),parseInt("",10),parseInt("",10);const m=1e4;var y=t;const{PublicKey:w,crypto:b,Script:g}=e.bitcore,{Point:v}=b;function S(t){let e=t.toBuffer().length+9;return t.isWitnessProgram()?e+=67.75:e+=148,3e4*e/1e3}function x(t){return y.from(t,"hex").toString().replace(/\0/g,"")}function _(t,e){return t.slice(e)+t.slice(0,e)}function O(t,e,r){if(t.length*Math.log2(e)>53)throw new Error(`Input too large ${t.length} ${Math.log2(e)}`);if(![2,10,16].includes(e)||![2,10,16].includes(r))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===e&&t.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===e&&t.length%2!=0)throw new Error("Hex strings must be of even length.");const n=parseInt(t,e).toString(r);return 2===r?n.padStart(8*Math.ceil(n.length/8),"0"):16===r?n.padStart(2*Math.ceil(n.length/2),"0"):n}function j(t,e){const r=new RegExp(`.{1,${e}}`,"g");return t.match(r)||[]}function E(t,e){const r=[];for(let n=0;n<t.length;n+=e)r.push(t.slice(n,n+e));return r}function $(t){return j(t,2).map((t=>O(t,16,2))).join("")}function C(t){return j(t,8).map((t=>O(t,2,16))).join("")}function T(t){if(62!==t.length)throw new Error("Input to hexToPublicKey must be of length 62");let e,r=!1,n=0;for(;!r;){if(n>=256)throw new Error("Something went wrong storing data");const i=n.toString(16).padStart(2,"0")+C(_($(t).padStart(64,"0"),n));try{e=v.fromX(!1,i),r=!0}catch(t){n+=1}}if(!e)throw new Error("Something went wrong storing data");return new w(e)}function P(t){const e=t.point.getX().toString("hex").padStart(64,"0"),r=O(e.slice(0,2),16,10),n=parseInt(r,10),i=e.slice(2);return C((o=$(i),s=n,o.slice(-s)+o.slice(0,-s)));var o,s}function I(t,e){const r={"any-testnet":"uTKUDCkpo12vstJBsMWmrTPz9wFE6DuzGH","BTC-mainnet":"igpnnoLziUyxtQuWYCP13gHYVhUru6iLaY","LTC-mainnet":"t77o829ngHnuUorwDkf129fL6ERLFNqKG8"};return _("testnet"===e||"regtest"===e?r["any-testnet"]:r[`${t}-${e}`],19)}function k(t=u,e=c){if("testnet"===e||"regtest"===e)return 1;if("BTC"===t)return 0;if("LTC"===t)return 2;if("DOGE"===t)return 3;if("BCH"===t)return 145;if("BSV"===t)return 236;throw new Error(`Unsupported chain ${t}`)}function K({purpose:t=44,coinType:e=2,account:r=0}={}){return`m/${t.toString()}'/${e.toString()}'/${r.toString()}'`}function A({chain:t=u,network:e=c}={}){return K({coinType:k(t,e)})}function D(t){const e=t;for(let t=e.length-1;t>0;t-=1){const r=Math.floor(Math.random()*(t+1));[e[t],e[r]]=[e[r],e[t]]}}function N(t,e){return w.fromString(function(t,e){const r={"any-testnet":"be88416b08d0bfcc88102c4d9b558662f570dbd0676e6fa167552117933f133b8d","BTC-mainnet":"cd3a3ef0281ab2ce66a02ea770fbc2c41e46816ab821c9a91435958284b4aaef13","LTC-mainnet":"12d020c11112a2839d302548072bddbdfbcd39472a54b45a016456b8e30ea631aa"};return _("testnet"===e||"regtest"===e?r["any-testnet"]:r[`${t}-${e}`],19)}(t,e))}function R({mnemonic:t=new e,path:r=A(),passphrase:n="",network:i=c}){return t.toHDPrivateKey(n,i).deriveChild(r)}function B(t){return/^[0-9A-Fa-f]{64}\/\d+$/.test(t)}function M(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function U(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function H(t){U(t);const[e,r]=t.split("/");return{txId:e,outputIndex:parseInt(r,10)}}const J=t=>t.startsWith("./")||t.startsWith("../")||"."===t||".."===t,L=t=>{const e=[],r={};let n=0;return t.forEach((t=>{"string"==typeof t?e.push(`'${t}'`):"number"==typeof t||"boolean"==typeof t?e.push(t):"object"==typeof t&&(t._rev?(e.push(`__bc${n}__`),r[`__bc${n}__`]=t._rev,n+=1):e.push(t))})),{argString:e.join(","),env:r}};function q(t){const e=[];let r,n=0;if(t.sort(((t,e)=>t-e))!==t)throw new Error("numbers must be in ascending order");for(let e=0;e<t.length;e+=1)if(t[e]===t[e+1])throw new Error("numbers must not contain duplicates");for(let i=0;n<t.length;i+=1)i===t[n]?(r="1",n+=1):r="0",e.unshift(r);return function(t,e){let r;if(t.length%e!=0){const n=t.length/e;r=Math.ceil(n)*e}return t.padStart(r,"0")}(e.join(""),2)}function z(t){const e=t.split("").reverse().join(""),r=[];for(let t=0;t<e.length;t+=1)"1"===e[t]&&r.push(t);return r}function F(t){const e=t.match(/.{1,8}/g)?.map((t=>parseInt(t,2)));return y.from(new Uint8Array(e).buffer)}function G(t){return Array.from(t).map((t=>t.toString(2).padStart(8,"0"))).join("")}function V(t){return F(t.map((t=>t.toString(2).padStart(12,"0"))).join(""))}function W(t){const e=G(t);return e.match(/.{1,12}/g).map((t=>parseInt(t,2)))}function Z(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}const{Transaction:Y}=e.bitcore,{UnspentOutput:Q}=Y;class X{constructor({chain:t,network:r,mnemonic:n,path:i,passphrase:o,url:s}={}){if(Z(this,"chain",void 0),Z(this,"network",void 0),Z(this,"mnemonic",void 0),Z(this,"path",void 0),Z(this,"passphrase",void 0),Z(this,"bcn",void 0),this.chain=t?t.toUpperCase():u,this.network=r?r.toLowerCase():c,this.mnemonic=new e(n?n.toString():void 0),this.path=i||A({chain:this.chain,network:this.network}),this.passphrase=o||"",this.bcn=new d(s,this.privateKey),!["LTC","BTC"].includes(this.chain))throw new Error("We currently only support LTC, support for other currencies will be added soon.");if(!["mainnet","testnet","regtest"].includes(this.network))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'")}get privateKey(){return R(this).privateKey}async getBalance(t){const{chain:e,network:r}=this;return await this.bcn.get(`/v1/${e}/${r}/address/${t}/balance`)}async getTransactions(t){return(await this.getRawTxs(t)).map((t=>new Y(t)))}async getRawTxs(t){t.map(M);const{chain:e,network:r}=this;return this.bcn.post(`/v1/${e}/${r}/tx/bulk/`,{txIds:t})}async sendTransaction(t){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{txJSON:t})}async getUtxosByAddress(t){const{chain:e,network:r}=this;return(await this.bcn.get(`/v1/${e}/${r}/wallet/${t.toString()}/utxos`)).map((({rev:e,scriptPubKey:r,satoshis:n})=>{const[i,o]=e.split("/");return new Q({address:t,txId:i,outputIndex:parseInt(o,10),satoshis:n,script:r})}))}async query(t){const{publicKey:e,classHash:r,limit:n,offset:i,order:o}=t;if(void 0===e&&void 0===r)throw new Error("Query parameters cannot be empty.");let s="";e&&(s+=`?publicKey=${e}`),r&&(s+=0===s.length?"?":"&",s+=`classHash=${r}`),void 0!==n&&(s+=`&limit=${n}`),void 0!==i&&(s+=`&offset=${i}`),o&&(s+=`&order=${o}`);const{chain:a,network:u}=this;return this.bcn.get(`/v1/${a}/${u}/non-standard-utxos${s}`)}async idsToRevs(t){t.map(U);const{chain:e,network:r}=this;return this.bcn.post(`/v1/${e}/${r}/revs`,{ids:t})}async rpc(t,e){return this.bcn.post(`/v1/${this.chain}/${this.network}/rpc`,{method:t,params:e})}static async getSecretOutput({_url:t,privateKey:e}){const r=t.split("/"),n=r[r.length-1],i=r.slice(0,-2).join("/"),o=new d(i,e);return{host:i,data:await o.get(`/v1/store/${n}`)}}static async setSecretOutput({secretOutput:t,host:e,privateKey:r}){return new d(e,r).post("/v1/store/",t)}static async deleteSecretOutput({_url:t,privateKey:e}){const r=t.split("/"),n=r[r.length-1],i=r.slice(0,-2).join("/"),o=new d(i,e);await o.delete(`/v1/store/${n}`)}get url(){return this.bcn.baseUrl}}var tt=t;const{PublicKey:et,Script:rt}=e.bitcore;function nt(t,e,r,n){if(t.length>3)throw new Error("Too many owners");return function(t,e,r,n){const i=n?[...t,N(e,r).toBuffer()]:t,o=new rt;return o.add("OP_1"),i.forEach((t=>{o.add(t)})),o.add(`OP_${i.length}`),o.add("OP_CHECKMULTISIG"),o}(t.map((t=>t.toBuffer())),e,r,n)}function it(t,e){return function(t,e){const r=t.chunks.filter((t=>t.buf));return(e?r.slice(0,-1):r).map((t=>t.buf))}(t,e).map((t=>et.fromBuffer(t)))}function ot(t,e,r,n){var i;return E(j((i=t,y.from(i).toString("hex")),62).map((t=>t.padStart(62,"0"))).map(T),n?2:3).map((t=>nt(t,e,r,n)))}function st(t,e,r,n,i,o){const s=q(n),a=F(s.padStart(8*Math.ceil(s.length/8),"0")),u=JSON.stringify(r),c=80-(6+a.length),l=u.slice(0,c),p=ot(u.slice(c),i,o,!0),f=V([t,e,e+p.length,s.length]),h=tt.from(l);return{opReturnBuffer:tt.concat([f,a,h]),dataScripts:p}}function at(t){const e=t.subarray(0,6),r=t.subarray(6),n=W(e),i=n[3],o=Math.ceil(i/8);return{ioDescriptor:n,ioMap:z(G(r.subarray(0,o))),dataPrefix:r.subarray(o).toString("utf8")}}var ut,ct,lt=t;function pt(t){return lt.from(i.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}function ft(t){return`${pt(t)};${t}`}function ht(t){const e=t.substr(0,4),r=t.substr(5);if(!function(t,e){return pt(t)===e}(r,e))throw new Error("Decryption failure");return r}function dt(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const r=lt.from(e,"hex").toString("binary"),n=ft(t);return i.AES.encrypt(n,r).toString()}function mt(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const r=lt.from(e,"hex").toString("binary");return ht(i.AES.decrypt(t,r).toString(i.enc.Utf8))}function yt(t,e){const r=n(32).toString("hex"),i=dt(t,r),s=e.map((t=>function(t,e){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(e))throw new Error("Invalid publicKey");const r=ft(t);return o(e,lt.from(r,"utf8")).toString("base64")}(r,t)));return{__cypher:i,__secrets:s}}function wt({__cypher:t,__secrets:e},r){let n="";if(r.forEach((r=>{e.forEach((e=>{try{const i=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return ht(s(e,lt.from(t,"base64")).toString("utf8"))}(e,r);n=mt(t,i)}catch(t){if(t instanceof Error&&!["Decryption failure","Unsupported state or unable to authenticate data"].includes(t.message))throw t}}))})),n)return n;throw new Error("Decryption failure")}(ct=ut||(ut={})).Array="Array",ct.Boolean="boolean",ct.Null="Null",ct.Number="number",ct.Object="Object",ct.String="string",ct.Undefined="undefined";const bt=["_owners","_readers","_amount"],gt=bt.concat(["_id","_rev","_root"]),vt=t=>(Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)||[])[1],St=t=>"object"==typeof t?vt(t):vt(t).toLowerCase(),xt=t=>St(t)===ut.Undefined,_t=t=>St(t)===ut.Null,Ot=t=>St(t)===ut.Number,jt=t=>_t(t)||xt(t)||Ot(t)||(t=>St(t)===ut.String)(t)||(t=>St(t)===ut.Boolean)(t),Et=t=>!jt(t)&&!Array.isArray(t),$t=t=>!jt(t)&&Array.isArray(t),Ct=t=>Et(t)?[Pt((([t])=>gt.includes(t)))(t)]:[],Tt=t=>e=>t.reduce(((t,r)=>(Object.keys(e).includes(r)&&(t[r]=e[r]),t)),{}),Pt=t=>e=>Object.fromEntries(Object.entries(e).filter((e=>t(e)))),It=t=>e=>{if(jt(e))return e;if($t(e))return e.filter(It(t));if(Et(e))return kt(It(t))((r=t,t=>{const e=Pt((([,t])=>r(t))),n=Object.create(Object.getPrototypeOf(t));return Object.assign(n,e(t))})(e));var r;throw new Error("Unsupported type")},kt=t=>e=>{const r=(n=([e,r])=>[e,t(r)],t=>Object.fromEntries(Object.entries(t).map(n)));var n;const i=Object.create(Object.getPrototypeOf(e));return Object.assign(i,r(e))},Kt=t=>e=>{if(jt(e))return t(e);if($t(e))return t(e.map(Kt(t)));if(Et(e))return t(kt(Kt(t))(e));throw new Error("Unsupported type")},At=Kt((t=>t)),Dt=t=>{return e=([e,r])=>[e,t(r)],t=>{Object.entries(t).forEach(e)};var e},Nt=t=>e=>{if(jt(e));else if($t(e))e.forEach(Nt(t));else{if(!Et(e))throw new Error("Unsupported type");{t(e);const r=Dt(Nt(t))(e),n=Object.create(Object.getPrototypeOf(e));Object.assign(n,r)}}},Rt=t=>e=>jt(e)?t(e):$t(e)?e.flatMap(Rt(t)):Et(e)?[...t(e),...Object.values(e).flatMap(Rt(t))]:[],Bt=t=>e=>r=>{if(jt(r))return t(r);if($t(r))return e([r,...r.flatMap(Bt(t)(e))]);if(Et(r))return e([r,...Object.values(r).flatMap(Bt(t)(e))]);throw new Error("Unsupported type")},Mt=t=>e=>Bt((t=>t))((e=>e.filter(t)))(e);function Ut(t){return Et(t)&&"_url"in t}function Ht(t){return Et(t)&&"__cypher"in t&&"__secrets"in t}function Jt(t){if(void 0!==t._readers){const{_readers:e,_url:r,_owners:n,_amount:i,...o}=t,s=yt(JSON.stringify(o),e);return void 0!==r&&(s._url=r),void 0!==n&&(s._owners=n),void 0!==i&&(s._amount=i),s}return t}function Lt(t,e){if(Ht(t)){const{__cypher:r,__secrets:n,...i}=t;return{...i,...JSON.parse(wt({__cypher:r,__secrets:n},e)),_readers:[]}}return t}function qt(t){return async e=>{if(void 0!==e._url){const{_url:r,_owners:n,_amount:i,...o}=e,s=await X.setSecretOutput({host:r,secretOutput:{data:JSON.stringify(o)},privateKey:t});return void 0!==n&&(s._owners=n),void 0!==i&&(s._amount=i),s}return e}}function zt(t){return async e=>{if(Ut(e)){const{_url:r,...n}=e,{host:i,data:o}=await X.getSecretOutput({_url:r,privateKey:t});return{...n,...JSON.parse(o),_url:i}}return e}}function Ft(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}const{Transaction:Gt}=e.bitcore,{Output:Vt,UnspentOutput:Wt}=Gt;class Zt{constructor({restClient:t=new X}={}){Ft(this,"tx",void 0),Ft(this,"outData",void 0),Ft(this,"restClient",void 0),this.tx=new Gt,this.tx.feePerKb(m),this.outData=[],this.restClient=t}get txId(){return this.tx.id}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}/${t.outputIndex}`))}get encoding(){const{outputs:t}=this.tx,e=t.filter((({script:t})=>t?.isDataOut())).map((({script:t})=>t.getData())),{ioDescriptor:r=[],ioMap:n=[],dataPrefix:i=""}=e.length?at(e[0]):{};return r.length&&r[0]>this.tx.inputs.length||r.length&&r[1]>this.tx.outputs.length||r.length&&r[2]>this.tx.outputs.length?{ioDescriptor:[],ioMap:[],dataPrefix:""}:{ioDescriptor:r,ioMap:n,dataPrefix:i}}get ioDescriptor(){return this.encoding.ioDescriptor}get dataPrefix(){return this.encoding.dataPrefix}get ioMap(){return this.encoding.ioMap}get inputsLength(){const[t=0]=this.ioDescriptor;return t}get outputsLength(){const[,t=0]=this.ioDescriptor;return t}get maxDataIndex(){const[,,t=-1]=this.ioDescriptor;return t}get ownerInputs(){return this.tx.inputs.slice(0,this.inputsLength)}get ownerOutputs(){return this.tx.outputs.slice(0,this.outputsLength)}get inRevs(){return this.ownerInputs.map((({prevTxId:t,outputIndex:e})=>`${t.toString("hex")}/${e}`))}get outRevs(){return this.ownerOutputs.map(((t,e)=>`${this.tx.id}/${e}`))}get zip(){return this.ownerOutputs.map(((t,e)=>[this.ioMap.indexOf(e)>=0?this.inRevs[this.ioMap.indexOf(e)]:null,this.outRevs[e]]))}isBcTx(){return this.tx.outputs.some((t=>t.script.toAddress(this.network).toString()===I(this.chain,this.network)))}getOwnerOutputs(){const[,t=0]=this.ioDescriptor;return this.tx.outputs.slice(0,t)}getDataOutputs(){const[,t,e]=this.ioDescriptor;return this.tx.outputs.slice(t,e)}async getOutData(){try{const e=this.getDataOutputs().map((t=>t.script)),r=(t=!0,e.map((e=>it(e,t))).flat().map(P).map(x).join("")),{dataPrefix:n}=this,i=JSON.parse(n+r),o=this.restClient.privateKey.toBuffer().toString("hex"),s=this.getOwnerOutputs();if(s.length!==i.length)throw new Error("Inconsistent state");const a=s.map(((t,e)=>({...i[e],_owners:it(t.script,!1).map((t=>t.toString())),_amount:t.satoshis})));return Promise.all(a.map((async t=>{try{return Lt(await zt(this.restClient.privateKey)(t),[o])}catch(t){return null}})))}catch(t){return[]}var t}getOwners(){return this.getOwnerOutputs().map((t=>it(t.script,!1).map((t=>t.toString()))))}getAmounts(){return this.getOwnerOutputs().map((t=>t.satoshis))}async spendFromData(t){if(!t.length)return;const r=t.map(H),n=r.map((t=>t.txId)),i=await this.restClient.getTransactions(n);for(let t=0;t<r.length;t+=1){const{txId:n,outputIndex:o}=r[t],{outputs:s}=i[t],a=s[o],u=Math.round(a.satoshis),c=new e.bitcore.Script(a.script),l=new Wt({txId:n,outputIndex:o,satoshis:u,script:c}),p=it(c,!1).map((t=>t.toString()));this.tx.from([l],p,1,{noSorting:!0})}}createDataOuts(t,r=[]){t.forEach((({_amount:t,_owners:r=[]})=>{if(Array.isArray(r)&&r.length>3)throw new Error("Too many owners.");const n=nt(r.map((t=>e.bitcore.PublicKey.fromString(t))),this.chain,this.network,!1),i=t||S(n);this.tx.addOutput(new Vt({script:n,satoshis:i}))}));const n=t.map((({_amount:t,_owners:e,...r})=>r)),{opReturnBuffer:i,dataScripts:o}=st(this.tx.inputs.length,this.tx.outputs.length,n,r,this.chain,this.network);o.forEach((t=>{const e=S(t);this.tx.addOutput(new Vt({script:t,satoshis:e}))})),this.tx.addData(i)}static getBcTx({hex:t="",restClient:e=new X}){const r=new this({restClient:e});return r.tx.fromString(t),r.outData=[],r}static async fromTxHex({hex:t="",restClient:e=new X}){let r=[],n=[],i=[];const o=new this({restClient:e});o.tx.fromString(t);try{r=await o.getOutData()}catch{}try{n=o.getOwners()}catch{}try{i=o.getAmounts()}catch{}return o.outData=r.map(((t,e)=>({...t,_owners:n[e],_amount:i[e]}))),o}static async fromTxId({txId:t="",restClient:e=new X}){const[r]=await e.getRawTxs([t]);return this.fromTxHex({hex:r,restClient:e})}}function Yt(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}class Qt{constructor(t={}){Yt(this,"restClient",void 0),this.restClient=new X(t)}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`,{chain:r,network:n,url:i,mnemonic:o,passphrase:s}=this.restClient;return new Qt({chain:r,network:n,url:i,mnemonic:o.toString(),path:e,passphrase:s})}async getBalance(){return this.restClient.getBalance(this.address)}async getUtxosByEffectiveValue(t){const r=await this.restClient.getUtxosByAddress(this.address);let n=0;const i=[];D(r);for(const o of r){const r=e.bitcore.Transaction.Input.fromObject({...o,prevTxId:o.txId,satoshis:o.amount})._estimateSize();if(o.satoshis-10*r>0&&(n+=o.satoshis-10*r,i.push(o)),n>=t)return i}const{network:o,chain:s}=this.restClient,a=this.address.toString();throw new Error(`Insufficient balance in address ${a} on ${o} ${s}. Found ${n}, required ${t}.`)}async fundAndSendTx(t){t.tx.feePerKb(m);const{chain:r,network:n}=this.restClient,i=Math.max(5e3,5820);t.tx.to(I(r,n),i);const o=t.tx._getInputAmount(),s=t.tx._getOutputAmount(),a=t.tx._estimateFee(),u=s-o+Math.round(a);if(u>0){(await this.getUtxosByEffectiveValue(u)).forEach((r=>{t.tx.from([new e.bitcore.Transaction.UnspentOutput(r)])}))}return t.tx.change(this.address.toString()),t.tx.sign(this.privateKey,1),this.restClient.sendTransaction(t.tx)}async send(t,e){const{restClient:r}=this,n=new Zt({restClient:r});return n.tx.to(e,t),this.fundAndSendTx(n)}get hdPrivateKey(){return R(this.restClient)}get privateKey(){return this.hdPrivateKey.privateKey}get publicKey(){return this.hdPrivateKey.publicKey}get passphrase(){return this.restClient.passphrase}get path(){return this.restClient.path}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get url(){return this.restClient.url}get mnemonic(){return this.restClient.mnemonic}get address(){return this.publicKey.toAddress(this.restClient.network)}}function Xt(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}class te{constructor(t={}){Xt(this,"wallet",void 0),this.wallet=new Qt(t)}async fromTxHex(t){const{restClient:e}=this.wallet;return Zt.fromTxHex({hex:t,restClient:e})}async fromTxId(t){const[e]=await this.wallet.restClient.getRawTxs([t]);return this.fromTxHex(e)}async get(t){const e=t.map(H);return Promise.all(e.map((async({txId:t,outputIndex:e})=>{const{outData:r}=await this.fromTxId(t);if(e>r.length)throw new Error("Index out of bounds");return r[e]})))}put(t){return this.update([],t)}getBcTx(t){const{restClient:e}=this.wallet;return Zt.getBcTx({hex:t,restClient:e})}async createTx(t,e,r=[]){const{wallet:n}=this,{restClient:i}=n,o=new Zt({restClient:i}),{privateKey:s,publicKey:a}=n,u=e.map((({_owners:t,...e})=>({_owners:t||[a.toString()],...e}))).map(Jt),c=await Promise.all(u.map(qt(s)));return await o.spendFromData(t),await o.createDataOuts(c,r),o}async update(t,e,r=[]){const n=await this.createTx(t,e,r);return await this.wallet.fundAndSendTx(n),n.outRevs}}const ee=new WeakSet;function re(t){ee.add(t)}let ne=!1;function ie(t){const e=ne;try{return ne=!0,t()}finally{ne=e}}function oe(){return ne}class se{set(t,e,r){if("_id"===e&&!oe())throw new Error("Cannot set _id");if("_rev"===e&&!oe())throw new Error("Cannot set _rev");if("_root"===e&&!oe())throw new Error("Cannot set _root");return Reflect.set(t,e,r)}}function ae(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}class ue{constructor(){ae(this,"_id",void 0),ae(this,"_rev",void 0),ae(this,"_root",void 0);const t=new Proxy(this,new se);return re(t),t}}function ce(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}class le{constructor({db:t=new te}={}){ce(this,"db",void 0),this.db=t}async deploy(t){const[e]=await this.db.put([{mod:t}]);return e}static bitcoinResolveHook(t){return t}static async bitcoinImportHook(t){const[e]=await(new te).get([t]);return new a(e.mod,t)}static nodeResolveHook(t="",e=""){if(void 0===t||void 0===e)throw new Error("!!! Invalid arguments");if(t.startsWith("/"))throw TypeError(`Module specifier ${t} must not begin with "/"`);if(!e.startsWith("./"))throw TypeError(`Module referrer ${e} must begin with "./"`);const r=[],n=[];J(t)&&(n.push(...e.split("/")),n.pop(),r.push(".")),n.push(...t.split("/"));for(const i of n)if("."===i||""===i);else if(".."===i){if(0===n.length){throw TypeError(`Module specifier ${t} via referrer ${e} must not traverse behind an empty path`)}r.pop()}else r.push(i);return r.join("/")}static resolveHook(t,e){if(B(e)&&!B(t))throw new Error("Requiring a local file from a module on the blockchain is not supported.");return B(t)?le.bitcoinResolveHook(t):le.nodeResolveHook(t,e)}static makeImportHook(){return t=>{if(B(t))return le.bitcoinImportHook(t);throw new Error("Not a valid import")}}static getBitcoinCompartment(){const{resolveHook:t,makeImportHook:e}=le;return new Compartment({Contract:ue},{},{resolveHook:t,importHook:e()})}static async import(t){const e=le.getBitcoinCompartment(),{namespace:r}=await e.import(t);return r}}var pe,fe,he,de,me={};function ye(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}pe=me,fe="Group",he=()=>Pe,de=t=>Pe=t,Object.defineProperty(pe,fe,{get:he,set:de,enumerable:!0,configurable:!0});class we{constructor(t){ye(this,"enc",void 0),ye(this,"type",void 0),this.enc=Ot(t)?t:_t(t)?{null:new we(1)}:xt(t)?{undefined:new we(1)}:$t(t)?kt((t=>new we(t)))(Object.fromEntries(Object.entries(t))):Et(t)?kt((t=>new we(t)))(t):{[t.toString()]:new we(1)},this.type=St(t)}}ye(we,"zero",(t=>({type:t,enc:t===ut.Number?0:{}}))),ye(we,"isZero",(t=>Se(t)?0===t.enc:0===Object.keys(t.enc).length)),ye(we,"isTopLevelReal",(t=>{const e=Object.keys(t.enc);return[ut.Array,ut.Object,ut.Number].includes(t.type)||1===e.length&&1===t.enc[e[0]].enc})),ye(we,"scalarMult",(t=>e=>{if(Se(e))return{type:e.type,enc:Number(e.enc)*t};if(je(e))return{type:e.type,enc:kt(we.scalarMult(t))(e.enc)};throw new Error(`Cannot multiply ${t} with ${e}`)})),ye(we,"add",(t=>e=>{if(t.type!==e.type)throw new Error(`Cannot add two vectors of different types: ${t.type} and ${e.type}`);if(Se(t)&&Se(e))return{type:ut.Number,enc:t.enc+e.enc};if(je(t)&&je(e)){const r=[...Object.keys(t.enc),...Object.keys(e.enc)].map((r=>{const n=t.enc[r]||we.zero(e.enc[r].type),i=e.enc[r]||we.zero(t.enc[r].type);return[r,we.add(n)(i)]})).filter((([,t])=>!we.isZero(t)));return{type:t.type,enc:Object.fromEntries(r)}}throw new Error(`Cannot add ${JSON.stringify(t,null,2)} and ${JSON.stringify(e,null,2)}`)})),ye(we,"toJson",(t=>{if(!we.isTopLevelReal(t))throw new Error("Cannot convert surreal to JSON");if(Se(t))return t.enc;if(Oe(t)){const e=Object.entries(t.enc),r=Object.fromEntries(e);return kt(we.toJson)(r)}if(_e(t)){return Object.entries(t.enc).reduce(((t,[e,r])=>(t[e]=we.toJson(r),t)),[])}const[e]=Object.keys(t.enc);if(t.type===ut.Null)return null;if(t.type!==ut.Undefined){if(t.type===ut.Boolean)return"true"===e;if(t.type===ut.String)return e;throw new Error("Invalid type")}}));const be=t=>t.type===ut.Null,ge=t=>t.type===ut.Undefined,ve=t=>t.type===ut.Boolean,Se=t=>t.type===ut.Number,xe=t=>t.type===ut.String,_e=t=>t.type===ut.Array,Oe=t=>t.type===ut.Object,je=t=>be(t)||ge(t)||ve(t)||xe(t)||_e(t)||Oe(t);var Ee;function $e(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Ce,Te=function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var a=t.length-1;a>=0;a--)(i=t[a])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};let Pe=($e(Ee=class{},"plus",(t=>e=>we.add(t)(e))),$e(Ee,"minus",(t=>e=>Ce.plus(t)(Ce.inverse(e)))),$e(Ee,"inverse",(t=>we.scalarMult(-1)(t))),$e(Ee,"zero",(t=>we.zero(t))),$e(Ee,"toJson",(t=>we.toJson(t))),$e(Ee,"fromJson",(t=>new we(t))),$e(Ee,"eq",(t=>e=>we.isZero(Ce.minus(t)(e)))),Ce=Ee);Pe=Ce=Te([t=>t],Pe);const Ie=t=>e=>r=>{if(void 0===e||void 0===r)throw new Error("projectTree: query or tree is undefined");if(e.type!==r.type)throw new Error("Type mismatch");if(Se(r))return r;if(je(r)){const n=Object.entries(r.enc).map((([r,n])=>t.includes(r)?[r,n]:Object.keys(e.enc).includes(r)?[r,Ie(t)(e.enc[r])(n)]:[r,we.zero(n.type)])).filter((([,t])=>!we.isZero(t)));return{enc:Object.fromEntries(n),type:e.type}}throw new Error("Invalid query")},ke=t=>e=>{const r=(t=>e=>{const r=me.Group.fromJson(t),n=me.Group.fromJson(e),i=me.Group.minus(n)(r);return Ie(gt)(i)(n)})(t)(e),n=me.Group.toJson(r);return Rt(Ct)(n)},Ke=t=>e=>{const r=ke(t)(e),n=r.map((t=>Et(t)&&"string"==typeof t._rev?t._rev:void 0));return{inputs:n,outputs:r.map(Tt(bt.concat("_rev")))}};function Ae(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}const De=Rt((t=>Et(t)&&t._rev?[t._rev]:[]));function Ne(t){if(jt(t))return!1;return Mt((t=>{return Et(t)&&(e=t,!ee.has(e));var e}))(t).length>0}class Re{constructor({db:t=new te}={}){Ae(this,"db",void 0),this.db=t}async read(t){const{txId:e}=H(t),{outData:r}=await this.db.fromTxId(e);if(!r.length)throw new Error(`No data found for output id ${t}`);const{exp:n,env:i,mod:o,root:s}=r[0],{getVal:a}=await this.getValAndTx(n,i,o,s),u=a(e);return Mt((e=>Et(e)&&e._rev&&e._rev===t))(u)[0]}async populateEnv(t){return Object.fromEntries(await Promise.all(Object.entries(t).map((async([t,e])=>{return[t,(r=e,"string"==typeof r&&B(r)?await this.read(e):e)];var r}))))}static async evaluate(t,e={},r=""){const n=r?await le.import(r):{};return new Compartment({Contract:ue,...e,...n}).evaluate(t)}async getValAndTx(t,e={},r="",n){if(/ super(\[|\.)/.test(t))throw new Error("Super is not allowed in smart contracts");if(n&&!Object.keys(e).includes(n))throw new Error(`Root ${n} not found in env.`);const i=await this.populateEnv(e),o=At(i);var s;s=i,Nt(re)(s);const a=await Re.evaluate(t,i,r);if(Ne(a)||Ne(i))throw new Error("Objects created inside smart contracts must inherit from Contract");const u=i[n],c=u&&(!jt(l=u)&&!Array.isArray(l)&&l._id&&l._rev&&l._root)?u?._root:void 0;var l;const p=t=>({_rev:"frame1",env:{_rev:"frame2",...t}}),f=p(o),h=p(i);"object"==typeof a&&(h.res=a);const d=Re.updateWithRevImpure((()=>Math.random().toString()));Nt(d)(h);if(m=o,y=i,me.Group.eq(me.Group.fromJson(m))(me.Group.fromJson(y))&&"object"!=typeof a)return{getVal:()=>({res:a,env:i})};var m,y;Re.markRootsImpure(o);const w=t=>Et(t)&&"_rev"in t?[t._rev]:[void 0],b=Rt(w)(h.env).filter((t=>void 0!==t)),g=Rt(w)(h.res).filter((t=>void 0!==t)),v=t=>new Set(t).size!==t.length;if(v(b)||v(g))throw new Error("Cannot create a circular object");const S=At(h),x=(t=>e=>{const r=De(t);if(void 0!==e&&!r.includes(e._rev))return It((t=>!Et(t)||!r.includes(t._rev)))(e)})(i)(a);"object"==typeof a&&(S.res=x),void 0===x&&delete S.res;const{inputs:_,outputs:O}=Ke(f)(S),j=_.filter(B),E=O.filter((t=>"frame1"!==t._rev&&"frame2"!==t._rev)),$=Object.fromEntries(E.map(((t,e)=>[t._rev,e]))),C=j.map((t=>$[t])),T=E.map(Tt(bt));T[0]={...T[0],exp:t,env:e,mod:r,root:n},h.res=a;const P=(t=>e=>r=>n=>{Et(n)&&n._rev&&Object.keys(e).includes(n._rev.toString())&&ie((()=>{n._rev=`${r}/${e[n._rev].toString()}`,n._id=n._id||n._rev,n._root=n._root||t||n._id}))})(c)($);return{sendTx:async()=>this.db.update(j,T,C),getVal:t=>(Nt(P(t))(h),h),ioMap:C}}}function Be(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}Ae(Re,"updateWithRevImpure",(t=>e=>{Et(e)&&void 0===e._rev&&ie((()=>{e._rev=t()}))})),Ae(Re,"markRootsImpure",(t=>{Dt((t=>{Et(t)&&(t[Math.random()]=1)}))(t)}));class Me{constructor({db:t=new te}={}){Be(this,"db",void 0),Be(this,"reader",void 0),Be(this,"modules",void 0),this.db=t,this.reader=new Re({db:t}),this.modules=new le({db:t}),Me.proxyDepth=Me.proxyDepth||0}async write(t,e={},r="",n){const{sendTx:i,getVal:o}=await this.reader.getValAndTx(t,e,r,n);if(i){const[t]=await i(),{txId:e}=H(t);return o(e)}return o("")}}function Ue(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}Be(Me,"proxyDepth",void 0);class He{constructor({db:t=new te}={}){Ue(this,"writer",void 0),this.writer=new Me({db:t})}get(t,e){return"function"!=typeof t[e]?Reflect.get(t,e):async(...r)=>{const{argString:n,env:i}=L(r),o=`__bc__.${String(e)}(${n})`,s={...i,__bc__:t._rev},{res:a,env:u}=await this.writer.write(o,s,"","__bc__"),{_rev:c,_id:l,_root:p,...f}=u;return Object.entries(f).forEach((([e,n])=>{const i=parseInt(e.slice(4,-2),10),o=Number.isNaN(i)?t:r[i];Object.entries(n).forEach((([t,e])=>{ie((()=>{o[t]=e}))}))})),a}}}var Je=t;function Le(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}const{bitcore:qe}=e,{crypto:ze}=qe;const Fe=class{constructor(t={}){if(Le(this,"db",void 0),void 0!==t.seed)throw new Error('The constructor parameter "seed" has been renamed to "mnemonic".');this.db=new te(t)}async write(t,e,r){const n=new Me({db:this.db}),{res:i}=await n.write(t,e,r),o=new He({db:this.db});return new Proxy(i,o)}async read(t){const e=new Re({db:this.db}),r=await e.read(t),n=new He({db:this.db});return new Proxy(r,n)}async new(t,e,r=""){const{db:n}=this,i=new Me({db:n}),o=new He({db:n}),{argString:s,env:a}=L(e||[]),u=`${t} new ${t.name}(${s})`,{res:c,env:l}=await i.write(u,a,r),{_rev:p,_id:f,_root:h,...d}=l;return Object.values(d).forEach(((t,r)=>{const n=e[r];Object.entries(t).forEach((([t,e])=>{ie((()=>{n[t]=e}))}))})),new Proxy(c,o)}async query(t){const{publicKey:e,contract:r,limit:n,offset:i,order:o}=t;let s={};if(e&&(s={...s,publicKey:new qe.PublicKey(e).toString()}),r){const t="string"==typeof r?r:r.toString();s={...s,classHash:ze.Hash.sha256(Je.from(t)).toString("hex")}}if("number"==typeof n||"number"==typeof i){if("number"==typeof n&&n<0)throw new Error("LIMIT must not be negative.");if("number"==typeof i&&i<0)throw new Error("OFFSET must not be negative.");void 0!==n&&(s={...s,limit:n.toString()}),void 0!==i&&(s={...s,offset:i.toString()}),s={...s,order:o||"ASC"}}return this.db.wallet.restClient.query(s)}async idsToRevs(t){return this.db.wallet.restClient.idsToRevs(t)}async deploy(t){return new le(this).deploy(t)}async import(t,e){return(await le.import(e))[t]}getChain(){return this.db.wallet.restClient.chain}getNetwork(){return this.db.wallet.restClient.network}getMnemonic(){return this.db.wallet.restClient.mnemonic.toString()}getPrivateKey(){return this.db.wallet.privateKey.toString()}getPublicKey(){return this.db.wallet.publicKey.toString()}getAddress(){return this.db.wallet.address.toString()}sign(t){t.sign(this.getPrivateKey(),1)}async getBalance(){return this.db.wallet.getBalance()}async getUtxos(){const t=new qe.Address(this.getAddress());return this.db.wallet.restClient.getUtxosByAddress(t)}async broadcast(t){return this.db.wallet.restClient.sendTransaction(t)}async sendTx(t){return this.broadcast(t.toObject())}async queryRevs(t){return this.query(t)}getOwnedRevs(t=this.db.wallet.publicKey){return this.query({publicKey:t.toString()})}async getRevs(t=this.db.wallet.publicKey){return this.query({publicKey:t.toString()})}async getLatestRevs(t){return this.idsToRevs(t)}async getLatestRev(t){const[e]=await this.idsToRevs([t]);return e}async rpcCall(t,e){const r=await this.db.wallet.restClient.rpc(t,e);return r.result?r.result:{}}async sync(t){return this.read(t)}},Ge=ue;globalThis.Contract=Ge;export{Fe as Computer,Ge as Contract};